"""
Node 2: Exploit Discovery
Discovers exploitation methods using multiple search strategies

═══════════════════════════════════════════════════════════════════════════════
METASPLOIT CONSOLE COMMANDS - FOR MANUAL TESTING
═══════════════════════════════════════════════════════════════════════════════

1. START METASPLOIT CONSOLE:
   $ msfconsole

2. SEARCH FOR EXPLOITS (what this node does):
   msf6 > search CVE-2004-2687                    # Strategy 1: CVE search
   msf6 > search vsftpd 2.3.4                     # Strategy 2: Service+Version
   msf6 > search vsftpd                           # Strategy 3: Fuzzy service
   msf6 > search auxiliary/scanner/ssh            # Strategy 4: Scanner modules
   msf6 > search auxiliary/gather/ssh             # Strategy 4: Gather modules

3. VIEW MODULE DETAILS:
   msf6 > info exploit/unix/misc/distcc_exec      # Show exploit details
   msf6 > info auxiliary/scanner/ssh/ssh_version  # Show auxiliary details

4. USE A MODULE:
   msf6 > use exploit/unix/misc/distcc_exec       # Load exploit
   msf6 exploit(unix/misc/distcc_exec) > show options  # Show required options
   msf6 exploit(unix/misc/distcc_exec) > set RHOSTS 192.168.1.100
   msf6 exploit(unix/misc/distcc_exec) > set LHOST 192.168.1.50
   msf6 exploit(unix/misc/distcc_exec) > exploit  # Run the exploit

5. SEARCH FILTERS:
   msf6 > search type:exploit platform:linux ssh  # Only Linux SSH exploits
   msf6 > search rank:excellent vsftpd            # Only excellent rank
   msf6 > search cve:2004 type:exploit            # CVE 2004 exploits

═══════════════════════════════════════════════════════════════════════════════
"""

from typing import Dict, List
import logging

# Import utilities
import sys
from pathlib import Path
sys.path.append(str(Path(__file__).parent.parent))

from ..utils.exploit_search import (
    get_module_path,
    extract_major_minor_version,
    search_exploits,
    module_to_dict,
    is_exploit_module,
    is_auxiliary_module,
    meets_rank_requirement,
    filter_exploits_smart,
)
from ..utils.logging_setup import log_node_start, log_node_end


def node_2_exploit_discovery(state: Dict) -> Dict:
    """
    Node 2: Discover exploits using multiple search strategies.

    ═══════════════════════════════════════════════════════════════════════════
    HOW IT WORKS - COMPLETE FLOW WITH EXAMPLE
    ═══════════════════════════════════════════════════════════════════════════

    Example Input State:
        target: "192.168.1.100"
        port: 21
        service: "vsftpd"
        version: "2.3.4"
        cve_ids: ["CVE-2011-2523"]

    STEP-BY-STEP EXECUTION:

    1. STRATEGY 1 - CVE Search:
       - Search for: "CVE-2011-2523"
       - MSF returns: [{"type": "exploit", "fullname": "exploit/unix/ftp/vsftpd_234_backdoor"}]
       - Result: 1 CVE exploit found (score: 1000) ✅

    2. STRATEGY 2 - Service/Version Search:
       - Exact search: "vsftpd 2.3.4"
       - MSF returns: [{"type": "exploit", "fullname": "exploit/unix/ftp/vsftpd_234_backdoor"}]
       - Skip: Already found in CVE search (duplicate)
       - Fuzzy search: "vsftpd 2.3" (if < 3 results)
       - Result: 0 new exploits (duplicate was skipped)

    3. STRATEGY 3 - Fuzzy Service Search:
       - Search for: "vsftpd"
       - MSF returns: [
           {"type": "exploit", "fullname": "exploit/unix/ftp/vsftpd_234_backdoor"},  ← duplicate
           {"type": "exploit", "fullname": "exploit/unix/ftp/vsftpd_smiley_face"},   ← new!
         ]
       - Skip duplicates
       - Apply filters (service in path, no Windows)
       - Result: 1 new fuzzy exploit (score: 400) ✅

    4. SMART FILTERING:
       - Total before filtering: 2 exploits (1 CVE + 1 fuzzy)
       - Case 1 applies: CVE found → ALL CVE + TOP 3 service + TOP 5 fuzzy
       - Result: 2 filtered exploits ✅

    Final Output State:
        exploits_from_cve: [vsftpd_234_backdoor]
        exploits_from_service: []
        exploits_from_fuzzy: [vsftpd_smiley_face]
        filtered_exploits: [vsftpd_234_backdoor, vsftpd_smiley_face]
        total_exploits_found: 2

    ═══════════════════════════════════════════════════════════════════════════
    STRATEGIES SUMMARY
    ═══════════════════════════════════════════════════════════════════════════

    Strategy 1: CVE-based matching (highest priority, score: 1000)
    Strategy 2: Service/Version matching (score: 800 exact, 600 fuzzy)
    Strategy 3: Fuzzy service matching (score: 400)
    Strategy 4: Auxiliary modules (fallback for info gathering)

    Smart Filtering:
        - CVE found: ALL CVE + TOP 3 service + TOP 5 fuzzy
        - No CVE, version found: TOP 5 service + TOP 10 fuzzy
        - Only fuzzy: TOP 20 fuzzy
        - Nothing: Auxiliary modules

    ═══════════════════════════════════════════════════════════════════════════

    Args:
        state: Red Agent state with target, service, version, cve_ids, msf_client

    Returns:
        Updated state with discovered exploits

    State updates:
        - exploits_from_cve: List of CVE-matched exploits
        - exploits_from_service: List of service/version-matched exploits
        - exploits_from_fuzzy: List of fuzzy-matched exploits
        - auxiliary_modules: List of auxiliary modules
        - filtered_exploits: Final optimized list (5-15 exploits)
        - total_exploits_found: Count before filtering
        - discovery_attempts: Number of attempts (for retry logic)
    """

    # Get logger
    logger = logging.getLogger("red_agent")

    # Initialize discovery state
    state.setdefault("exploits_from_cve", [])
    state.setdefault("exploits_from_service", [])
    state.setdefault("exploits_from_fuzzy", [])
    state.setdefault("auxiliary_modules", [])
    state.setdefault("filtered_exploits", [])
    state.setdefault("total_exploits_found", 0)
    state.setdefault("discovery_attempts", 0)

    # Increment discovery attempts
    state["discovery_attempts"] += 1

    # Log node start
    log_node_start(logger, "EXPLOIT DISCOVERY", 2)

    # Get MSF client
    client = state.get("msf_client")
    if not client:
        logger.error("❌ Metasploit client not available")
        return state

    # Get search parameters
    service = state.get("service", "unknown")
    version = state.get("version", "")
    cve_ids = state.get("cve_ids", [])

    logger.info(f"Target: {service} {version}")
    logger.info(f"CVE IDs: {', '.join(cve_ids) if cve_ids else 'None'}")
    logger.info(f"Discovery attempt: {state['discovery_attempts']}")
    logger.info("")

    # ═══════════════════════════════════════════════════════════════════
    # STRATEGY 1: CVE-BASED MATCHING
    # ═══════════════════════════════════════════════════════════════════
    logger.info("STRATEGY 1: CVE-Based Search")

    exploits_from_cve = []

    if cve_ids:
        for cve_id in cve_ids:
            logger.info(f"  Searching for CVE: {cve_id}")

            # STEP 1: Search MSF for CVE
            # Example: search_exploits(client, "CVE-2004-2687")
            #
            # MSF Console Equivalent:
            #   msf6 > search CVE-2004-2687
            #
            results = search_exploits(client, cve_id)

            # Returns (example):
            # [
            #     {
            #         "type": "exploit",
            #         "fullname": "exploit/unix/misc/distcc_exec",
            #         "name": "DistCC Daemon Command Execution",
            #         "rank": "excellent",
            #         "description": "This module uses a documented feature of distcc...",
            #         "references": ["CVE-2004-2687", "OSVDB-13378"],
            #         "platform": "unix",
            #         "disclosuredate": "2002-02-01"
            #     }
            # ]
            # If no exploits found: []

            exploit_count = 0
            # STEP 2: Loop through each module (dictionary) returned by MSF
            # Example iteration:
            #   module = {"type": "exploit", "fullname": "exploit/unix/misc/distcc_exec", "rank": "excellent"}
            for module in results:
                # STEP 3: Check if this module is an exploit (not auxiliary)
                # Example: is_exploit_module(module) checks if module["type"] == "exploit"
                # Result: True ✅ → Keep processing | False ❌ → Skip to next module
                if is_exploit_module(module):
                    # STEP 4: Convert MSF dict to our clean format with score
                    # Example: module_to_dict creates {"path": "exploit/unix/misc/distcc_exec", "score": 1000, ...}
                    exploit_info = module_to_dict(module, "cve", score=1000)

                    # STEP 5: Add to our CVE exploits list
                    exploits_from_cve.append(exploit_info)
                    exploit_count += 1

            logger.info(f"  → Found {exploit_count} exploit(s) for {cve_id}")

        state["exploits_from_cve"] = exploits_from_cve
        logger.info(f"  Total CVE exploits: {len(exploits_from_cve)}")
    else:
        logger.info("  → No CVE IDs provided, skipping")

    logger.info("")

    # ═══════════════════════════════════════════════════════════════════
    # STRATEGY 2: SERVICE/VERSION MATCHING
    # ═══════════════════════════════════════════════════════════════════
    logger.info("STRATEGY 2: Service/Version Search")

    exploits_from_service = []

    if service and service != "unknown":
        # ═══════════════════════════════════════════════════════════════
        # EXACT VERSION SEARCH
        # ═══════════════════════════════════════════════════════════════
        # Example: If user provides service="vsftpd" and version="2.3.4"
        #          We search for "vsftpd 2.3.4" (exact match)
        if version:
            query = f"{service} {version}"
            logger.info(f"  Exact search: '{query}'")

            # Search MSF with service + version
            # Example: search_exploits(client, "vsftpd 2.3.4")
            #
            # MSF Console Equivalent:
            #   msf6 > search vsftpd 2.3.4
            #
            results = search_exploits(client, query)

            # Returns (example):
            # [
            #     {
            #         "type": "exploit",
            #         "fullname": "exploit/unix/ftp/vsftpd_234_backdoor",
            #         "name": "VSFTPD v2.3.4 Backdoor Command Execution",
            #         "rank": "excellent",
            #         "description": "This module exploits a malicious backdoor...",
            #         "references": ["CVE-2011-2523", "OSVDB-73573"],
            #         "platform": "unix",
            #         "disclosuredate": "2011-07-03"
            #     }
            # ]
            # If no exploits found: []

            for module in results:
                # Skip if already in CVE results
                if any(e["path"] == get_module_path(module) for e in exploits_from_cve):
                    continue

                if is_exploit_module(module) and meets_rank_requirement(module, "average"):
                    exploit_info = module_to_dict(module, "service_version", score=800)
                    exploits_from_service.append(exploit_info)

            logger.info(f"  → Found {len(exploits_from_service)} exploit(s)")

            # ═══════════════════════════════════════════════════════════════
            # FUZZY VERSION SEARCH (if exact version finds < 3 exploits)
            # ═══════════════════════════════════════════════════════════════
            # Example: If version="2.3.4" found only 1 exploit
            #          Try fuzzy search with "2.3" (major.minor only)
            # Why:     Some exploits work across patch versions
            #          e.g., exploit for 2.3.x works on 2.3.4, 2.3.5, etc.
            if len(exploits_from_service) < 3 and "." in version:
                # Extract major.minor from version
                # Example: "2.3.4" → "2.3"
                #          "7.4p1" → "7.4"
                fuzzy_version = extract_major_minor_version(version)
                fuzzy_query = f"{service} {fuzzy_version}"
                logger.info(f"  Fuzzy search: '{fuzzy_query}'")

                # Search with fuzzy version
                # Example: search_exploits(client, "openssh 7.4")
                #
                # MSF Console Equivalent:
                #   msf6 > search openssh 7.4
                #
                fuzzy_results = search_exploits(client, fuzzy_query)

                # Returns (example):
                # [
                #     {
                #         "type": "exploit",
                #         "fullname": "exploit/linux/ssh/libssh_auth_bypass",
                #         "name": "libssh Authentication Bypass",
                #         "rank": "great",
                #         "description": "This module exploits an authentication bypass...",
                #         "references": ["CVE-2018-10933"],
                #         "platform": "linux",
                #         "disclosuredate": "2018-10-16"
                #     },
                #     {
                #         "type": "exploit",
                #         "fullname": "exploit/unix/ssh/openssh_maxauth",
                #         "name": "OpenSSH MaxAuthTries Exhaustion DoS",
                #         "rank": "normal",
                #         "disclosuredate": "2015-08-16"
                #     }
                # ]
                # May find exploits for 7.4, 7.4p1, 7.4p2, etc. (fuzzy matching)

                fuzzy_count = 0
                for module in fuzzy_results:
                    # Skip duplicates
                    if any(e["path"] == get_module_path(module) for e in exploits_from_cve + exploits_from_service):
                        continue

                    if is_exploit_module(module) and meets_rank_requirement(module, "average"):
                        exploit_info = module_to_dict(module, "service_version", score=600)
                        exploits_from_service.append(exploit_info)
                        fuzzy_count += 1

                logger.info(f"  → Found {fuzzy_count} additional exploit(s) with fuzzy version")

        state["exploits_from_service"] = exploits_from_service
        logger.info(f"  Total service/version exploits: {len(exploits_from_service)}")
    else:
        logger.info("  → No service name available, skipping")

    logger.info("")

    # ═══════════════════════════════════════════════════════════════════
    # STRATEGY 3: FUZZY SERVICE MATCHING
    # ═══════════════════════════════════════════════════════════════════
    logger.info("STRATEGY 3: Fuzzy Service Search")

    exploits_from_fuzzy = []

    if service and service != "unknown":
        logger.info(f"  Searching for: '{service}'")

        # STEP 1: Search MSF for service name only (fuzzy/broad search)
        # Example: search_exploits(client, "ssh")
        #
        # MSF Console Equivalent:
        #   msf6 > search ssh
        #
        results = search_exploits(client, service)

        # Returns (example - many results, needs filtering!):
        # [
        #   {
        #       "type": "exploit",
        #       "fullname": "exploit/unix/ssh/openssh_login",        ← SSH related ✅
        #       "name": "OpenSSH Login",
        #       "rank": "manual"
        #   },
        #   {
        #       "type": "exploit",
        #       "fullname": "exploit/linux/ssh/libssh_auth_bypass",  ← SSH related ✅
        #       "name": "libssh Authentication Bypass",
        #       "rank": "great"
        #   },
        #   {
        #       "type": "exploit",
        #       "fullname": "exploit/linux/http/php_imap_open_rce",  ← NOT SSH related ❌
        #       "name": "PHP imap_open RCE",
        #       "rank": "good"
        #   },
        #   {
        #       "type": "exploit",
        #       "fullname": "exploit/windows/ssh/putty_msg_debug",   ← Windows ❌
        #       "name": "PuTTY SSH Message Debug",
        #       "rank": "normal"
        #   },
        #   {
        #       "type": "auxiliary",                                  ← Auxiliary (not exploit) ❌
        #       "fullname": "auxiliary/scanner/ssh/ssh_version",
        #       "name": "SSH Version Scanner"
        #   }
        # ]
        # ⚠️ This returns MANY unrelated results - we need SMART FILTERING!

        filtered_count = 0
        # STEP 2: Loop through each module
        for module in results:
            # SKIP CHECK 1: Is this exploit already found in CVE or Service search?
            # Example: If "exploit/unix/ssh/openssh_login" was already found by CVE search, skip it
            if any(e["path"] == get_module_path(module) for e in exploits_from_cve + exploits_from_service):
                continue

            # SKIP CHECK 2: Is this an exploit? Is rank "average" or better?
            # Accept average+ exploits (excludes only "low" and "manual")
            if not is_exploit_module(module) or not meets_rank_requirement(module, "average"):
                continue

            # STEP 3: Get the module path for filtering
            # Example: module_path = "exploit/linux/http/php_imap_open_rce"
            module_path = get_module_path(module).lower()

            # ═══════════════════════════════════════════════════════════════
            # SMART FILTER 1: Service name should be in module path
            # ═══════════════════════════════════════════════════════════════
            # Example 1 (SSH search):
            #   service = "ssh"
            #   module_path = "exploit/unix/ssh/openssh_login"
            #   Check: Is "/ssh/" in path? → YES ✅ → PASS (keep this)
            #
            # Example 2 (SSH search):
            #   service = "ssh"
            #   module_path = "exploit/linux/http/php_imap_open_rce"
            #   Check: Is "/ssh/" in path? → NO ❌
            #   Check: Is "ssh" in filename "php_imap_open_rce"? → NO ❌
            #   Result: SKIP this exploit (it's PHP/HTTP, not SSH)
            #
            # Example 3 (FTP search):
            #   service = "ftp"
            #   module_path = "exploit/unix/misc/vsftpd_234_backdoor"
            #   Check: Is "/ftp/" in path? → NO ❌
            #   Check: Is "ftp" in filename "vsftpd_234_backdoor"? → YES ✅ (contains "ftp")
            #   Result: PASS (keep this)
            if f"/{service.lower()}/" not in module_path:
                # Also check if service is in the last part (filename)
                path_parts = module_path.split("/")
                # path_parts = ["exploit", "unix", "misc", "vsftpd_234_backdoor"]
                # Check last part: path_parts[-1] = "vsftpd_234_backdoor"
                if service.lower() not in path_parts[-1]:
                    filtered_count += 1
                    continue  # SKIP - Service name not found in path

            # ═══════════════════════════════════════════════════════════════
            # SMART FILTER 2: Always skip Windows exploits (targets are always Linux)
            # ═══════════════════════════════════════════════════════════════
            # Example:
            #   module_path = "exploit/windows/local/unquoted_service_path"
            #   Check: Is "windows" in path? → YES ❌
            #   Result: SKIP (our targets are Linux only)
            if "windows" in module_path:
                filtered_count += 1
                continue  # SKIP - Windows exploit on Linux target

            # STEP 4: This exploit passed all filters! Add it to our list
            exploit_info = module_to_dict(module, "fuzzy", score=400)
            exploits_from_fuzzy.append(exploit_info)

        state["exploits_from_fuzzy"] = exploits_from_fuzzy
        logger.info(f"  → Found {len(exploits_from_fuzzy)} exploit(s)")
        if filtered_count > 0:
            logger.info(f"  → Filtered out {filtered_count} unrelated exploit(s)")
    else:
        logger.info("  → No service name available, skipping")

    logger.info("")

    # ═══════════════════════════════════════════════════════════════════
    # SMART FILTERING
    # ═══════════════════════════════════════════════════════════════════
    logger.info("SMART FILTERING")

    filtered_exploits, total = filter_exploits_smart(
        exploits_from_cve,
        exploits_from_service,
        exploits_from_fuzzy
    )

    state["filtered_exploits"] = filtered_exploits
    state["total_exploits_found"] = total

    logger.info(f"  Total before filtering: {total}")
    logger.info(f"  After smart filtering: {len(filtered_exploits)} exploits")
    logger.info("")

    # ═══════════════════════════════════════════════════════════════════
    # STRATEGY 4: AUXILIARY MODULES (FALLBACK)
    # ═══════════════════════════════════════════════════════════════════

    if len(filtered_exploits) == 0:
        logger.info("STRATEGY 4: Auxiliary Modules (Fallback)")
        logger.info("  No exploits found, searching for auxiliary modules...")

        auxiliary_modules = []

        if service and service != "unknown":
            # Search for scanner modules
            scanner_query = f"auxiliary/scanner/{service}"
            logger.info(f"  Searching: '{scanner_query}'")

            # MSF Console Equivalent:
            #   msf6 > search auxiliary/scanner/ssh
            #
            scanner_results = search_exploits(client, scanner_query)

            # Returns (example):
            # [
            #     {
            #         "type": "auxiliary",
            #         "fullname": "auxiliary/scanner/ssh/ssh_version",
            #         "name": "SSH Version Scanner",
            #         "rank": "normal",
            #         "description": "Detect SSH version"
            #     },
            #     {
            #         "type": "auxiliary",
            #         "fullname": "auxiliary/scanner/ssh/ssh_login",
            #         "name": "SSH Login Check Scanner",
            #         "rank": "normal",
            #         "description": "This module will test ssh logins..."
            #     },
            #     {
            #         "type": "auxiliary",
            #         "fullname": "auxiliary/scanner/ssh/ssh_enumusers",
            #         "name": "SSH Username Enumeration",
            #         "rank": "normal"
            #     }
            # ]
            for module in scanner_results:
                if is_auxiliary_module(module):
                    aux_info = module_to_dict(module, "auxiliary", score=100)
                    auxiliary_modules.append(aux_info)

            # Search for gather modules
            gather_query = f"auxiliary/gather/{service}"
            logger.info(f"  Searching: '{gather_query}'")

            # MSF Console Equivalent:
            #   msf6 > search auxiliary/gather/ssh
            #
            gather_results = search_exploits(client, gather_query)

            # Returns (example):
            # [
            #     {
            #         "type": "auxiliary",
            #         "fullname": "auxiliary/gather/ssh_credentials",
            #         "name": "SSH Credential Collection",
            #         "rank": "normal",
            #         "description": "This module will collect SSH credentials..."
            #     },
            #     {
            #         "type": "auxiliary",
            #         "fullname": "auxiliary/gather/enum_ssh",
            #         "name": "SSH Information Gathering",
            #         "rank": "normal"
            #     }
            # ]
            # If no gather modules found: []
            for module in gather_results:
                if is_auxiliary_module(module):
                    # Skip duplicates
                    if not any(a["path"] == get_module_path(module) for a in auxiliary_modules):
                        aux_info = module_to_dict(module, "auxiliary", score=100)
                        auxiliary_modules.append(aux_info)

            state["auxiliary_modules"] = auxiliary_modules
            logger.info(f"  → Found {len(auxiliary_modules)} auxiliary module(s)")
            logger.info("")

    # ═══════════════════════════════════════════════════════════════════
    # SUMMARY
    # ═══════════════════════════════════════════════════════════════════
    logger.info("DISCOVERY SUMMARY")
    logger.info(f"  CVE exploits: {len(exploits_from_cve)}")
    logger.info(f"  Service/Version exploits: {len(exploits_from_service)}")
    logger.info(f"  Fuzzy exploits: {len(exploits_from_fuzzy)}")
    logger.info(f"  Auxiliary modules: {len(state.get('auxiliary_modules', []))}")
    logger.info(f"  Filtered exploits: {len(filtered_exploits)}")
    logger.info("")

    # Determine next step
    if len(filtered_exploits) > 0:
        logger.info("✅ Exploits found! Ready for ranking and selection")
    elif len(state.get("auxiliary_modules", [])) > 0:
        logger.info("ℹ️  No exploits, but auxiliary modules available for info gathering")
    else:
        logger.info("⚠️  No exploits or auxiliary modules found")

    log_node_end(logger, "Node 2", True)

    return state
