"""
Exploit Search Utilities
Helper functions for searching and filtering Metasploit modules
"""

from typing import List, Dict, Tuple


def get_module_path(module) -> str:
    """
    Get fullname/path from module (handles both dict and object).

    Args:
        module: MSF module (dict or object)

    Returns:
        Module fullname/path

    Example 1 - Dictionary (from search):
        Input:  module = {
                    "fullname": "exploit/unix/ssh/openssh_login",
                    "name": "OpenSSH Login",
                    "type": "exploit"
                }
        Code:   isinstance(module, dict)  # True ✅
                return module.get("fullname", "unknown")
        Output: "exploit/unix/ssh/openssh_login"

    Example 2 - Object (from use):
        Input:  module = <MsfModule object>
                module.fullname = "exploit/unix/ftp/vsftpd_234_backdoor"
        Code:   isinstance(module, dict)  # False ❌
                return getattr(module, "fullname", "unknown")
        Output: "exploit/unix/ftp/vsftpd_234_backdoor"

        WHAT IS getattr()? (Simple explanation)
            getattr() = "Get Attribute" = Get a property from an object

            Think of an object like a person:
                person.name = "John"
                person.age = 25

            Two ways to get the name:
                1. Direct access:    person.name  → "John"
                2. Using getattr():  getattr(person, "name")  → "John"

            Why use getattr() instead of direct access?
                SAFE DEFAULT if attribute doesn't exist!

                Direct access (CRASHES):
                    person.name      → "John" ✅
                    person.address   → AttributeError: 'Person' object has no attribute 'address' ❌ CRASH!

                Using getattr() (SAFE):
                    getattr(person, "name", "unknown")     → "John" ✅
                    getattr(person, "address", "unknown")  → "unknown" ✅ No crash!

            In our code:
                module is an OBJECT (not dict)
                getattr(module, "fullname", "unknown")
                     ↓         ↓           ↓
                 From this  Get this   If missing,
                  object  attribute   return this

            Real flow:
                1. Look for module.fullname
                2. If found: return "exploit/unix/ftp/vsftpd_234_backdoor"
                3. If NOT found: return "unknown" (instead of crashing)

    Example 3 - Missing fullname (ERROR CASE):
        Input:  module = {"name": "Some Module"}  # No "fullname" key!
        Code:   module.get("fullname", "unknown")  # Returns default
        Output: "unknown"

    WHY "unknown"? What does it mean?
        "unknown" is our SAFE DEFAULT when data is missing or corrupted.

        WITHOUT "unknown" (DANGEROUS):
            module["fullname"]  → KeyError: 'fullname' ❌ CRASH!
            OR
            module.fullname     → AttributeError ❌ CRASH!
            Result: Entire Node 2 stops, no exploits found!

        WITH "unknown" (SAFE):
            module.get("fullname", "unknown")  → "unknown" ✅ No crash!
            Result: Code keeps running, we can still find other exploits!

        What happens to "unknown" modules?
            - They get logged for debugging
            - They're skipped in filtering (can't match paths)
            - Other valid exploits still work fine

        Real-world example:
            MSF returns 10 exploits, 1 has corrupted data:
            - Without "unknown": CRASH! Get 0 exploits ❌
            - With "unknown": Skip bad one, get 9 good exploits ✅

    SUMMARY - .get() vs getattr():
        Both do the SAME THING for different types!

        For DICTIONARIES (dict):
            module.get("fullname", "unknown")
                ↓
            Get key "fullname" from dict, if missing return "unknown"

        For OBJECTS (object):
            getattr(module, "fullname", "unknown")
                ↓
            Get attribute "fullname" from object, if missing return "unknown"

        Side-by-side comparison:
            Dictionary method:              Object method:
            module["fullname"]        VS    module.fullname          ← Direct (can crash)
            module.get("fullname")    VS    getattr(module, "fullname")  ← Safe (returns None)
            module.get("key", "x")    VS    getattr(module, "attr", "x")  ← Safe with default

    What it does: Safely extracts the "fullname" (path) regardless of whether
                  module is a dict or object. Returns "unknown" if data is missing
                  to prevent crashes.
    """
    if isinstance(module, dict):
        return module.get("fullname", "unknown")  # For dictionary: use .get()
    else:
        return getattr(module, "fullname", "unknown")  # For object: use getattr()


def extract_major_minor_version(version: str) -> str:
    """
    Extract major.minor version from full version string.

    Args:
        version: Full version string (e.g., "2.3.4", "7.4p1")

    Returns:
        Major.minor version (e.g., "2.3", "7.4")

    Example 1:
        Input:  "2.3.4"
        Code:   parts = "2.3.4".split(".")  # ["2", "3", "4"]
                parts = parts[:2]             # ["2", "3"] (take first 2)
                return ".".join(parts)        # "2" + "." + "3" = "2.3"
        Output: "2.3"

    Example 2:
        Input:  "7.4p1"
        Code:   parts = "7.4p1".split(".")  # ["7", "4p1"]
                parts = parts[:2]            # ["7", "4p1"]
                return ".".join(parts)       # "7.4p1"
        Output: "7.4p1"

    Example 3:
        Input:  "1.2.3.4"
        Code:   parts = "1.2.3.4".split(".")  # ["1", "2", "3", "4"]
                parts = parts[:2]              # ["1", "2"]
                return ".".join(parts)         # "1.2"
        Output: "1.2"

    Example 4 - No dots:
        Input:  "5"
        Code:   "." not in version  # True
                return version
        Output: "5" (unchanged)

    Example 5 - Empty:
        Input:  ""
        Code:   not version  # True
                return version
        Output: ""

    Why we use this: Exploits often work across patch versions.
                     e.g., exploit for "2.3.x" works on 2.3.0, 2.3.4, 2.3.5, etc.
    """
    if not version or "." not in version:
        return version

    # Split by dot and take first 2 parts
    parts = version.split(".")[:2]
    return ".".join(parts)


def search_exploits(client, query: str) -> List:
    """
    Search Metasploit modules with error handling.

    Args:
        client: MsfRpcClient instance
        query: Search query string

    Returns:
        List of module objects (empty list on error)

    Example:
        Input:  search_exploits(client, "ssh")

        MSF Console Equivalent:
            msf6 > search ssh

        Output: [
                    {"type": "exploit", "fullname": "exploit/unix/ssh/openssh_login", "rank": "good"},
                    {"type": "exploit", "fullname": "exploit/windows/ssh/putty_msg", "rank": "normal"},
                    {"type": "auxiliary", "fullname": "auxiliary/scanner/ssh/ssh_version"}
                ]

        What it does: Asks Metasploit "find all modules related to 'ssh'"
                      Returns a LIST of DICTIONARIES (each dict = one module)

        Behind the scenes:
            client.modules.search(query)  →  Runs: "search ssh" in msfconsole
    """
    try:
        results = client.modules.search(query)
        return results if results else []
    except Exception as e:
        print(f"Warning: MSF search error for '{query}': {e}")
        return []


def module_to_dict(module, matched_by: str, score: int) -> Dict:
    """
    Convert MSF module (dict or object) to dictionary with metadata.

    ═══════════════════════════════════════════════════════════════════════════
    PURPOSE - Why do we need this function? (Simple English)
    ═══════════════════════════════════════════════════════════════════════════

    PROBLEM:
        Metasploit gives us messy, inconsistent data with too much info!

        Example of MSF module (has 50+ fields!):
            {
                "fullname": "exploit/unix/misc/distcc_exec",
                "name": "DistCC Daemon Command Execution",
                "rank": "excellent",
                "type": "exploit",
                "description": "This module uses a documented feature...",
                "references": ["CVE-2004-2687", "BID-9915", "OSVDB-13378"],
                "platform": "unix",
                "disclosuredate": "2002-02-01",
                "author": ["hdm <hdm@metasploit.com>"],
                "license": "Metasploit Framework License (BSD)",
                "privileged": false,
                "check": true,
                "targets": [...],
                "default_target": 0,
                "stance": "aggressive",
                ... and 40 more fields we don't need!
            }

        Problems with this:
            ❌ Too much unnecessary data (slow, takes memory)
            ❌ Key names are inconsistent ("fullname" vs "path")
            ❌ Missing our metadata (how we found it, priority score)
            ❌ Hard to compare exploits across different strategies

    SOLUTION - What this function does:
        ✅ Clean up: Extract ONLY the fields we need (path, name, rank, etc.)
        ✅ Standardize: Always use same key names ("path" instead of "fullname")
        ✅ Add metadata: Track HOW we found it (CVE? Service? Fuzzy?)
        ✅ Add priority: Assign score (1000 for CVE, 800 for Service, 400 for Fuzzy)

        Before (MSF module - 50+ fields):
            {"fullname": "...", "name": "...", ... 48 more fields}

        After (our clean dict - 9 fields):
            {
                "path": "exploit/unix/misc/distcc_exec",     ← Renamed from "fullname"
                "name": "DistCC Daemon Command Execution",
                "rank": "excellent",
                "description": "This module uses...",
                "references": ["CVE-2004-2687"],
                "platform": "unix",
                "disclosure_date": "2002-02-01",
                "matched_by": "cve",                         ← NEW! We added this
                "score": 1000                                ← NEW! We added this
            }

    WHY IS THIS USEFUL?

        1. FASTER PROCESSING
           - Less data to store and transfer
           - Only keep what we need for decision-making

        2. EASIER COMPARISON
           - All exploits have same structure
           - Easy to sort by score/rank
           - Easy to filter duplicates

        3. TRACK DISCOVERY METHOD
           - "matched_by" tells us HOW we found this exploit
           - CVE search? → matched_by="cve", score=1000 (highest priority)
           - Service search? → matched_by="service_version", score=800
           - Fuzzy search? → matched_by="fuzzy", score=400 (lowest priority)

        4. PRIORITIZATION
           - Score helps us pick best exploits
           - Same exploit found by CVE (score 1000) beats one from Fuzzy (score 400)
           - In deduplication, we keep the higher score

    REAL EXAMPLE - How it helps:

        Without module_to_dict():
            - Store 50 fields × 20 exploits = 1000 fields in memory
            - Can't compare exploits easily (different structures)
            - Don't know which strategy found which exploit
            - Can't prioritize (all exploits look the same)

        With module_to_dict():
            - Store 9 fields × 20 exploits = 180 fields in memory (5x smaller!)
            - All exploits have same clean structure
            - "matched_by" tells us discovery method
            - "score" tells us priority
            - Easy to sort, filter, deduplicate!

    WHERE WE USE IT:
        - Strategy 1 (CVE): module_to_dict(module, "cve", score=1000)
        - Strategy 2 (Service): module_to_dict(module, "service_version", score=800)
        - Strategy 3 (Fuzzy): module_to_dict(module, "fuzzy", score=400)
        - Strategy 4 (Auxiliary): module_to_dict(module, "auxiliary", score=100)

    ═══════════════════════════════════════════════════════════════════════════

    Args:
        module: MSF module (dict from search or object from use)
        matched_by: How this exploit was found ("cve", "service_version", "fuzzy")
        score: Priority score for filtering

    Returns:
        Dictionary with exploit metadata

    Example 1 - Dictionary input (from search):
        Input:  module = {
                    "fullname": "exploit/unix/misc/distcc_exec",
                    "name": "DistCC Daemon Command Execution",
                    "rank": "excellent",
                    "type": "exploit",
                    "description": "This module uses...",
                    "references": ["CVE-2004-2687"],
                    "platform": "unix",
                    "disclosuredate": "2002-02-01"
                }
                matched_by = "cve"
                score = 1000

        Output: {
                    "path": "exploit/unix/misc/distcc_exec",
                    "name": "DistCC Daemon Command Execution",
                    "rank": "excellent",
                    "description": "This module uses...",
                    "references": ["CVE-2004-2687"],
                    "targets": [],
                    "platform": "unix",
                    "disclosure_date": "2002-02-01",
                    "matched_by": "cve",
                    "score": 1000
                }

    Example 2 - Object input (from use):
        Input:  module = <MsfModule object>
                module.fullname = "exploit/unix/ftp/vsftpd_234_backdoor"
                module.name = "VSFTPD v2.3.4 Backdoor"
                module.rank = "excellent"
                matched_by = "service_version"
                score = 800

        Output: {
                    "path": "exploit/unix/ftp/vsftpd_234_backdoor",
                    "name": "VSFTPD v2.3.4 Backdoor",
                    "rank": "excellent",
                    "matched_by": "service_version",
                    "score": 800,
                    ...
                }

    WHY use "unknown" as defaults?
        Same reason as get_module_path() - CRASH PREVENTION!

        If MSF module is missing data:
            WITHOUT defaults: KeyError/AttributeError → CRASH ❌
            WITH "unknown":   Graceful degradation → Keep running ✅

        Example of missing data handling:
            module = {"fullname": "exploit/unix/ssh/test"}  # Missing name, rank, etc.

            return {
                "path": "exploit/unix/ssh/test",      ← Got it ✅
                "name": "unknown",                     ← Missing, but safe ❌→✅
                "rank": "unknown",                     ← Missing, but safe ❌→✅
                "description": "",                     ← Missing, empty string
                ...
            }

        This exploit can still be used! We know the path, can load it.
        "unknown" just means "data not available, but not critical".

    What it does: Creates a clean, standardized dictionary with:
                  - Original module info (path, name, rank, etc.)
                  - Metadata we added (matched_by, score)
                  - Handles both dict and object inputs safely
                  - Uses "unknown" defaults to prevent crashes from missing data
    """
    try:
        # Handle both dict (from search) and object (from use)
        if isinstance(module, dict):
            return {
                "path": module.get("fullname", "unknown"),  # "unknown" = safe default if missing
                "name": module.get("name", "unknown"),       # Better than crashing!
                "rank": module.get("rank", "unknown"),       # Code keeps running
                "description": module.get("description", ""),
                "references": module.get("references", []),
                "targets": module.get("targets", []),
                "platform": module.get("platform", ""),
                "disclosure_date": module.get("disclosuredate", ""),
                "matched_by": matched_by,
                "score": score,
            }
        else:
            # Object from client.modules.use()
            return {
                "path": getattr(module, "fullname", "unknown"),
                "name": getattr(module, "name", "unknown"),
                "rank": getattr(module, "rank", "unknown"),
                "description": getattr(module, "description", ""),
                "references": getattr(module, "references", []),
                "targets": getattr(module, "targets", []),
                "platform": getattr(module, "platform", ""),
                "disclosure_date": getattr(module, "disclosure_date", ""),
                "matched_by": matched_by,
                "score": score,
            }
    except Exception as e:
        print(f"Warning: Error extracting module info: {e}")
        return {
            "path": "unknown",
            "name": "unknown",
            "rank": "unknown",
            "matched_by": matched_by,
            "score": score,
        }


def is_exploit_module(module) -> bool:
    """
    Check if module is an exploit type.

    Args:
        module: MSF module (dict or object)

    Returns:
        True if module type is "exploit"

    Example:
        Input 1: module = {"type": "exploit", "fullname": "exploit/unix/ssh/openssh_login"}
        Output:  True  ✅ (This is an exploit - we WANT this)

        Input 2: module = {"type": "auxiliary", "fullname": "auxiliary/scanner/ssh/ssh_version"}
        Output:  False ❌ (This is auxiliary - we SKIP this)

        What it does: Checks if module["type"] == "exploit"
                      We only want exploits (attack tools), not auxiliary (scanners)
    """
    try:
        if isinstance(module, dict):
            return module.get("type", "").lower() == "exploit"
        else:
            return getattr(module, "type", "").lower() == "exploit"
    except:
        return False


def is_auxiliary_module(module) -> bool:
    """
    Check if module is an auxiliary type.

    Args:
        module: MSF module (dict or object)

    Returns:
        True if module type is "auxiliary"
    """
    try:
        if isinstance(module, dict):
            return module.get("type", "").lower() == "auxiliary"
        else:
            return getattr(module, "type", "").lower() == "auxiliary"
    except:
        return False


def rank_to_score(rank: str) -> int:
    """
    Convert MSF rank to numeric score for sorting.

    Args:
        rank: MSF rank string (excellent/great/good/normal/average/low/manual)

    Returns:
        Numeric score (higher = better)

    Example 1:
        Input:  "excellent"
        Output: 50 (highest score - most reliable exploit)

    Example 2:
        Input:  "good"
        Output: 30

    Example 3:
        Input:  "manual"
        Output: 1 (lowest score - requires manual interaction)

    Example 4 - Case insensitive:
        Input:  "EXCELLENT"
        Code:   rank.lower()  # "excellent"
        Output: 50

    Example 5 - Unknown rank (ERROR CASE):
        Input:  "weird"
        Code:   rank_scores.get("weird", 0)  # Not in dict, return 0
        Output: 0

    Example 6 - "unknown" rank (from module_to_dict):
        Input:  "unknown"  # Module had missing rank data
        Code:   rank_scores.get("unknown", 0)  # In dict, mapped to 0
        Output: 0

    Rank hierarchy (best to worst):
        excellent (50) > great (40) > good (30) > normal (20) > average (10) > low (5) > manual (1) > unknown (0)

    WHY "unknown" = 0?
        "unknown" rank means we don't know how reliable the exploit is.

        WITHOUT "unknown" handling:
            module = {"rank": "unknown"}  # From corrupted/incomplete data
            rank_to_score("unknown")  → Returns 0 using .get() default
            meets_rank_requirement(...) → Exploit gets LOWEST priority
            Result: Exploit is sorted to bottom of list ✅

        What happens:
            - Exploit isn't rejected completely
            - But it's given lowest priority (score 0)
            - Better exploits with known ranks go first
            - "unknown" rank exploits are backup options

        Real example:
            exploits = [
                {"rank": "excellent", "score": 1000},  ← Try this first
                {"rank": "good", "score": 400},        ← Then this
                {"rank": "unknown", "score": 400}      ← Last resort (rank=0)
            ]

    Why we use this: To compare and sort exploits by reliability.
                     Higher score = more likely to succeed.
                     "unknown" = 0 puts unverified exploits at bottom.
    """
    rank_scores = {
        "excellent": 50,
        "great": 40,
        "good": 30,
        "normal": 20,
        "average": 10,
        "low": 5,
        "manual": 1,
        "unknown": 0,  # Lowest priority - we don't know reliability
    }
    return rank_scores.get(rank.lower(), 0)  # If rank not in dict at all, also return 0


def meets_rank_requirement(module, min_rank: str = "average") -> bool:
    """
    Check if module meets minimum rank requirement.

    Args:
        module: MSF module (dict or object)
        min_rank: Minimum required rank (default: "average")

    Returns:
        True if module rank >= min_rank

    Example 1 - PASS:
        Input:  module = {"rank": "excellent", "fullname": "exploit/unix/misc/distcc_exec"}
                min_rank = "normal"
        Code:   module_score = rank_to_score("excellent")  # 50
                min_score = rank_to_score("normal")         # 20
                return 50 >= 20  # True ✅
        Output: True (excellent >= normal)

    Example 2 - PASS:
        Input:  module = {"rank": "good", "fullname": "exploit/linux/ssh/libssh"}
                min_rank = "good"
        Code:   module_score = rank_to_score("good")  # 30
                min_score = rank_to_score("good")     # 30
                return 30 >= 30  # True ✅
        Output: True (good >= good, equal is OK)


    Example 3 - FAIL:
        Input:  module = {"rank": "normal", "fullname": "exploit/unix/ssh/openssh"}
                min_rank = "good"
        Code:   module_score = rank_to_score("normal")  # 20
                min_score = rank_to_score("good")       # 30
                return 20 >= 30  # False ❌
        Output: False (normal < good, doesn't meet requirement)

    Example 4 - FAIL:
        Input:  module = {"rank": "manual", "fullname": "exploit/..."}
                min_rank = "normal"
        Code:   module_score = rank_to_score("manual")  # 1
                min_score = rank_to_score("normal")     # 20
                return 1 >= 20  # False ❌
        Output: False (manual < normal)

    How we use it:
        - Strategy 2 (Service): min_rank = "average" (accept average+)
        - Strategy 3 (Fuzzy): min_rank = "average" (accept average+)

    Why: We accept "average" rank and above (excellent, great, good, normal, average).
         We exclude only "low" and "manual" ranks (low quality or needs human interaction).
    """
    if isinstance(module, dict):
        rank = module.get("rank", "unknown").lower()
    else:
        rank = getattr(module, "rank", "unknown").lower()

    module_score = rank_to_score(rank)
    min_score = rank_to_score(min_rank)

    return module_score >= min_score


def deduplicate_exploits(exploits: List[Dict]) -> List[Dict]:
    """
    Remove duplicate exploits based on module path.
    Keep the entry with highest score.

    Args:
        exploits: List of exploit dictionaries

    Returns:
        Deduplicated list of exploits

    Example - Before deduplication:
        Input: [
            {"path": "exploit/unix/ftp/vsftpd_234_backdoor", "score": 1000, "matched_by": "cve"},
            {"path": "exploit/linux/ssh/libssh_auth_bypass", "score": 800, "matched_by": "service_version"},
            {"path": "exploit/unix/ftp/vsftpd_234_backdoor", "score": 600, "matched_by": "service_version"},  ← DUPLICATE!
            {"path": "exploit/unix/ssh/openssh_login", "score": 400, "matched_by": "fuzzy"}
        ]

    Processing:
        seen = {}

        Iteration 1: path = "exploit/unix/ftp/vsftpd_234_backdoor"
            path not in seen → Add it
            seen = {"exploit/unix/ftp/vsftpd_234_backdoor": {score: 1000, matched_by: "cve"}}

        Iteration 2: path = "exploit/linux/ssh/libssh_auth_bypass"
            path not in seen → Add it
            seen = {
                "exploit/unix/ftp/vsftpd_234_backdoor": {score: 1000, matched_by: "cve"},
                "exploit/linux/ssh/libssh_auth_bypass": {score: 800, matched_by: "service_version"}
            }

        Iteration 3: path = "exploit/unix/ftp/vsftpd_234_backdoor" ← DUPLICATE!
            path in seen → Compare scores
            Current score: 600 vs Existing score: 1000
            600 > 1000? NO ❌ → Keep existing (higher score)

        Iteration 4: path = "exploit/unix/ssh/openssh_login"
            path not in seen → Add it

    Output: [
        {"path": "exploit/unix/ftp/vsftpd_234_backdoor", "score": 1000, "matched_by": "cve"},  ← Kept highest score
        {"path": "exploit/linux/ssh/libssh_auth_bypass", "score": 800, "matched_by": "service_version"},
        {"path": "exploit/unix/ssh/openssh_login", "score": 400, "matched_by": "fuzzy"}
    ]
    # Reduced from 4 to 3 exploits (removed duplicate with lower score)

    Why we need this: Same exploit can be found by multiple strategies.
                      e.g., vsftpd backdoor found by both CVE and Service+Version.
                      We keep the one with highest score (CVE = 1000 > Service = 600)
    """
    seen = {}

    for exploit in exploits:
        path = exploit.get("path", "")

        if path not in seen:
            seen[path] = exploit
        else:
            # Keep exploit with higher score
            if exploit.get("score", 0) > seen[path].get("score", 0):
                seen[path] = exploit

    return list(seen.values())


def sort_exploits(exploits: List[Dict]) -> List[Dict]:
    """
    Sort exploits by score, rank, and disclosure date.

    Sorting order:
    1. Score (highest first)
    2. Rank (excellent > great > good > normal > average > low)
    3. Disclosure date (newer first)

    Args:
        exploits: List of exploit dictionaries

    Returns:
        Sorted list of exploits

    Example - Before sorting:
        Input: [
            {"path": "exploit/A", "score": 400, "rank": "good", "disclosure_date": "2020-01-01"},
            {"path": "exploit/B", "score": 1000, "rank": "excellent", "disclosure_date": "2010-01-01"},
            {"path": "exploit/C", "score": 800, "rank": "normal", "disclosure_date": "2022-01-01"},
            {"path": "exploit/D", "score": 800, "rank": "great", "disclosure_date": "2021-01-01"}
        ]

    Sorting process:
        For each exploit, create sort_key tuple:

        Exploit A: score=400, rank=good(30), date=2020-01-01
            sort_key = (-400, -30, "2020-01-01")

        Exploit B: score=1000, rank=excellent(50), date=2010-01-01
            sort_key = (-1000, -50, "2010-01-01")

        Exploit C: score=800, rank=normal(20), date=2022-01-01
            sort_key = (-800, -20, "2022-01-01")

        Exploit D: score=800, rank=great(40), date=2021-01-01
            sort_key = (-800, -40, "2021-01-01")

        Comparison (using tuple comparison):
            (-1000, -50, "2010-01-01") < (-800, -40, "2021-01-01")  # B comes first (higher score)
            (-800, -40, "2021-01-01") < (-800, -20, "2022-01-01")   # D comes first (higher rank)
            (-800, -20, "2022-01-01") < (-400, -30, "2020-01-01")   # C comes first (higher score)

    Output: [
        {"path": "exploit/B", "score": 1000, "rank": "excellent", "disclosure_date": "2010-01-01"},  ← 1st: Highest score
        {"path": "exploit/D", "score": 800, "rank": "great", "disclosure_date": "2021-01-01"},      ← 2nd: Same score as C, but higher rank
        {"path": "exploit/C", "score": 800, "rank": "normal", "disclosure_date": "2022-01-01"},     ← 3rd: Lower rank than D
        {"path": "exploit/A", "score": 400, "rank": "good", "disclosure_date": "2020-01-01"}        ← 4th: Lowest score
    ]

    Why we use negative scores: sorted() sorts ascending by default.
                                Using negative values (-1000, -800, -400) makes it descending.
                                -1000 < -800 < -400 in ascending = 1000 > 800 > 400 in descending
    """
    def sort_key(exploit):
        score = exploit.get("score", 0)
        rank = exploit.get("rank", "unknown")
        rank_score = rank_to_score(rank)
        disclosure_date = exploit.get("disclosure_date", "")

        # Return tuple for sorting (all descending)
        # Negative values convert ascending sort to descending
        return (-score, -rank_score, disclosure_date)

    return sorted(exploits, key=sort_key, reverse=True)


def filter_exploits_smart(
    exploits_from_cve: List[Dict],
    exploits_from_service: List[Dict],
    exploits_from_fuzzy: List[Dict]
) -> Tuple[List[Dict], int]:
    """
    Smart filtering to optimize exploit count (5-15, max 20).

    Filtering logic:
    - Case 1: CVE found → ALL CVE + TOP 3 service + TOP 5 fuzzy
    - Case 2: No CVE, version found → TOP 5 service + TOP 10 fuzzy
    - Case 3: Only fuzzy → TOP 20 fuzzy

    Args:
        exploits_from_cve: List from CVE search
        exploits_from_service: List from service/version search
        exploits_from_fuzzy: List from fuzzy search

    Returns:
        Tuple of (filtered_exploits, total_count_before_filtering)

    Example 1 - CVE Found:
        Input:  CVE: 2 exploits, Service: 10 exploits, Fuzzy: 30 exploits (Total: 42)
        Output: 2 CVE + 3 Service + 5 Fuzzy = 10 exploits ✅
        Why:    CVE is most reliable, so we take ALL CVE exploits

    Example 2 - No CVE, but Service found:
        Input:  CVE: 0 exploits, Service: 8 exploits, Fuzzy: 25 exploits (Total: 33)
        Output: 5 Service + 10 Fuzzy = 15 exploits ✅
        Why:    Service+Version is reliable, take TOP 5

    Example 3 - Only Fuzzy:
        Input:  CVE: 0 exploits, Service: 0 exploits, Fuzzy: 50 exploits (Total: 50)
        Output: 20 Fuzzy exploits ✅
        Why:    Fuzzy is less reliable, limit to TOP 20
    """
    # Calculate total BEFORE filtering
    total = len(exploits_from_cve) + len(exploits_from_service) + len(exploits_from_fuzzy)
    filtered = []

    # Sort all lists by score/rank before filtering
    # This ensures we get the BEST exploits from each category
    cve_sorted = sort_exploits(exploits_from_cve)
    service_sorted = sort_exploits(exploits_from_service)
    fuzzy_sorted = sort_exploits(exploits_from_fuzzy)

    # Case 1: CVE found (highest priority)
    if len(cve_sorted) > 0:
        filtered.extend(cve_sorted)  # Take ALL CVE exploits
        filtered.extend(service_sorted[:5])  # TOP 3 from service
        filtered.extend(fuzzy_sorted[:5])  # TOP 5 from fuzzy

    # Case 2: No CVE, but service/version found
    elif len(service_sorted) > 0:
        filtered.extend(service_sorted[:5])  # TOP 5 from service
        filtered.extend(fuzzy_sorted[:10])  # TOP 10 from fuzzy

    # Case 3: Only fuzzy matches
    elif len(fuzzy_sorted) > 0:
        filtered.extend(fuzzy_sorted[:20])  # TOP 20 from fuzzy

    # Deduplicate (in case same exploit appears in multiple strategies)
    # Example: If "exploit/unix/ssh/openssh_login" appears in both CVE and Service,
    #          keep only the one with higher score
    filtered = deduplicate_exploits(filtered)

    return filtered, total
