"""
SSH Exploitation Routes - For executing commands on Metasploitable 2
"""

from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
import paramiko
import logging

router = APIRouter(prefix="/api/ssh", tags=["ssh"])

# SSH session storage (in production, use Redis or database)
ssh_sessions = {}

logger = logging.getLogger(__name__)

class SSHConnectRequest(BaseModel):
    host: str
    username: str = "msfadmin"
    password: str = "msfadmin"
    port: int = 22

class SSHCommandRequest(BaseModel):
    session_id: str
    command: str

class SSHDisconnectRequest(BaseModel):
    session_id: str

@router.post("/connect")
async def ssh_connect(request: SSHConnectRequest):
    """Connect to SSH server"""
    try:
        logger.info(f"[*] Attempting SSH connection to {request.host}:{request.port}")

        # Create SSH client
        client = paramiko.SSHClient()
        client.set_missing_host_key_policy(paramiko.AutoAddPolicy())

        # Connect
        client.connect(
            request.host,
            port=request.port,
            username=request.username,
            password=request.password,
            allow_agent=False,
            look_for_keys=False,
            timeout=10
        )

        # Store session
        session_id = f"{request.host}_{id(client)}"
        ssh_sessions[session_id] = {
            "client": client,
            "host": request.host,
            "username": request.username,
            "connected": True
        }

        logger.info(f"[+] SSH connected: {session_id}")
        return {
            "status": "connected",
            "session_id": session_id,
            "message": f"Successfully connected to {request.host}",
            "host": request.host,
            "user": request.username
        }

    except Exception as e:
        logger.error(f"[-] SSH connection error: {str(e)}")
        raise HTTPException(status_code=400, detail=f"Connection failed: {str(e)}")

@router.post("/execute")
async def ssh_execute(request: SSHCommandRequest):
    """Execute command on SSH server"""
    try:
        session_id = request.session_id
        command = request.command

        if session_id not in ssh_sessions:
            raise HTTPException(status_code=404, detail="Session not found")

        if not ssh_sessions[session_id]["connected"]:
            raise HTTPException(status_code=400, detail="Session disconnected")

        client = ssh_sessions[session_id]["client"]

        logger.info(f"[*] Executing: {command}")
        stdin, stdout, stderr = client.exec_command(command)

        output = stdout.read().decode('utf-8', errors='ignore')
        error = stderr.read().decode('utf-8', errors='ignore')

        result = output if output else error

        return {
            "command": command,
            "output": result,
            "status": "success"
        }

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"[-] Command execution error: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Execution failed: {str(e)}")

@router.post("/disconnect")
async def ssh_disconnect(request: SSHDisconnectRequest):
    """Disconnect SSH session"""
    try:
        session_id = request.session_id

        if session_id not in ssh_sessions:
            raise HTTPException(status_code=404, detail="Session not found")

        ssh_sessions[session_id]["client"].close()
        ssh_sessions[session_id]["connected"] = False
        del ssh_sessions[session_id]

        logger.info(f"[+] SSH disconnected: {session_id}")
        return {"status": "disconnected", "message": "Session closed"}

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"[-] Disconnection error: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Disconnection failed: {str(e)}")
